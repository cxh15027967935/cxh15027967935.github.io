<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>setstate原理</title>
      <link href="/2022/05/19/setstate%E5%8E%9F%E7%90%86/"/>
      <url>/2022/05/19/setstate%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>setState: React 中用于修改状态，更新视图。它具有以下特点:</li></ul><p><strong>异步与同步:</strong> setState并不是单纯的异步或同步，这其实与调用时的环境相关:</p><ul><li><p>在合成事件和生命周期钩子</p><p>(除 componentDidUpdate) 中，setState是”异步”的；</p><ul><li>原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；<ul><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li><li>在合成事件中，React 是基于 事务流完成的事件委托机制实现，也是处于事务流中；</li></ul></li><li>问题: 无法在setState后马上从this.state上获取更新后的值。</li><li>解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；</li></ul></li><li><p>在原生事件和 setTimeout 中，setState是同步的，可以马上获取更新后的值；</p><ul><li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li></ul></li><li><p><strong>批量更新</strong>: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</p></li><li><p>函数式</p><p>: 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) =&gt; newState)；</p><ul><li>使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；</li></ul></li></ul><p><strong>注意事项:</strong></p><ul><li>setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</li><li>当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法<ul><li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li><li>在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；</li></ul></li></ul><p><strong>总结</strong></p><blockquote><p>setState 并非真异步，只是看上去像异步。在源码中，通过 <code>isBatchingUpdates</code> 来判断</p></blockquote><ul><li><code>setState</code> 是先存进 <code>state</code> 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</li><li>那么什么情况下 <code>isBatchingUpdates</code> 会为 <code>true</code> 呢？在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li><li>但在 React 无法控制的地方，比如原生事件，具体就是在 <code>addEventListener</code> 、<code>setTimeout</code>、<code>setInterval</code> 等事件中，就只能同步更新。</li></ul><blockquote><p>一般认为，<code>做异步设计是为了性能优化、减少渲染次数</code>，React 团队还补充了两点。</p></blockquote><ul><li>保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。</li><li>启用并发更新，完成异步渲染。</li></ul><ol><li><code>setState</code> 只有在 React 自身的合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步的</li><li><code>setState</code> 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的异步。当然可以通过 setState 的第二个参数中的 callback 拿到更新后的结果</li><li><code>setState</code> 的批量更新优化也是建立在异步（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在异步中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，去最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新</li></ol><ul><li>合成事件中是异步</li><li>钩子函数中的是异步</li><li>原生事件中是同步</li><li>setTimeout中是同步</li></ul><p><img src="/2022/05/19/setstate%E5%8E%9F%E7%90%86/20210409153900.png"></p><p><strong>setState异步更新</strong></p><ul><li>我们都知道，<code>React</code>通过<code>this.state</code>来访问<code>state</code>，通过<code>this.setState()</code>方法来更新<code>state</code>。当<code>this.setState()</code>方法被调用的时候，<code>React</code>会重新调用<code>render</code>方法来重新渲染<code>UI</code></li><li>首先如果直接在<code>setState</code>后面获取<code>state</code>的值是获取不到的。在<code>React</code>内部机制能检测到的地方， <code>setState</code>就是异步的；<code>在React</code>检测不到的地方，例如<code>setInterval</code>,<code>setTimeout</code>，<code>setState</code>就是同步更新的</li></ul><ul><li><code>setState</code>方法通过一个队列机制实现<code>state</code>更新，当执行<code>setState</code>的时候，会将需要更新的<code>state</code>合并之后放入状态队列，而不会立即更新<code>this.state</code></li><li>如果我们不使用<code>setState</code>而是使用<code>this.state.key</code>来修改，将不会触发组件的<code>re-render</code>。</li><li>如果将<code>this.state</code>赋值给一个新的对象引用，那么其他不在对象上的<code>state</code>将不会被放入状态队列中，当下次调用<code>setState</code>并对状态队列进行合并时，直接造成了<code>state</code>丢失</li></ul><p><strong>setState批量更新的过程</strong></p><p>在<code>react</code>生命周期和合成事件执行前后都有相应的钩子，分别是<code>pre</code>钩子和<code>post</code>钩子，<code>pre</code>钩子会调用<code>batchedUpdate</code>方法将<code>isBatchingUpdates</code>变量置为<code>true</code>，开启批量更新，而<code>post</code>钩子会将<code>isBatchingUpdates</code>置为<code>false</code></p><ul><li><code>isBatchingUpdates</code>变量置为<code>true</code>，则会走批量更新分支，<code>setState</code>的更新会被存入队列中，待同步代码执行完后，再执行队列中的<code>state</code>更新。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code>的组件）放入 <code>dirtyComponents</code> 数组中；否则 <code>batchUpdate</code> 所有队列中的更新</li><li>而在原生事件和异步操作中，不会执行<code>pre</code>钩子，或者生命周期的中的异步操作之前执行了<code>pre</code>钩子，但是<code>pos</code>钩子也在异步操作之前执行完了，<code>isBatchingUpdates</code>必定为<code>false</code>，也就不会进行批量更新</li></ul><blockquote><p><code>enqueueUpdate</code>包含了<code>React</code>避免重复<code>render</code>的逻辑。<code>mountComponent</code>和<code>updateComponent</code>方法在执行的最开始，会调用到<code>batchedUpdates</code>进行批处理更新，此时会将<code>isBatchingUpdates</code>设置为<code>true</code>，也就是将状态标记为现在正处于更新阶段了。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code> 的组件）放入<code>dirtyComponents</code> 数组中；否则 <code>batchUpdate</code> 所有队列中的更新</p></blockquote><p><strong>为什么直接修改this.state无效</strong></p><ul><li>要知道<code>setState</code>本质是通过一个队列机制实现<code>state</code>更新的。 执行<code>setState</code>时，会将需要更新的state合并后放入状态队列，而不会立刻更新<code>state</code>，队列机制可以批量更新<code>state</code>。</li><li>如果不通过<code>setState</code>而直接修改<code>this.state</code>，那么这个<code>state</code>不会放入状态队列中，下次调用<code>setState</code>时对状态队列进行合并时，会忽略之前直接被修改的<code>state</code>，这样我们就无法合并了，而且实际也没有把你想要的<code>state</code>更新上去</li></ul><p><strong>什么是批量更新 Batch Update</strong></p><blockquote><p>在一些<code>mv*</code>框架中，，就是将一段时间内对<code>model</code>的修改批量更新到<code>view</code>的机制。比如那前端比较火的<code>React</code>、<code>vue</code>（<code>nextTick</code>机制,视图的更新以及实现）</p></blockquote><p><strong>setState之后发生的事情</strong></p><ul><li><code>setState</code>操作并不保证是同步的，也可以认为是异步的</li><li><code>React</code>在<code>setState</code>之后，会经对<code>state</code>进行<code>diff</code>，判断是否有改变，然后去<code>diff dom</code>决定是否要更新<code>UI</code>。如果这一系列过程立刻发生在每一个<code>setState</code>之后，就可能会有性能问题</li><li>在短时间内频繁<code>setState</code>。<code>React</code>会将<code>state</code>的改变压入栈中，在合适的时机，批量更新<code>state</code>和视图，达到提高性能的效果</li></ul><p><strong>1.5 如何知道state已经被更新</strong></p><blockquote><p>传入回调函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="number">1</span></span><br><span class="line">&#125;&#125;, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在钩子函数中体现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. setState循环调用风险</strong></p><ul><li>当调用<code>setState</code>时，实际上会执行<code>enqueueSetState</code>方法，并对<code>partialState</code>以及<code>_pending-StateQueue</code>更新队列进行合并操作，最终通过<code>enqueueUpdate</code>执行<code>state</code>更新</li><li>而<code>performUpdateIfNecessary</code>方法会获<code>取_pendingElement</code>,<code>_pendingStateQueue</code>，<code>_pending-ForceUpdate</code>，并调用<code>receiveComponent</code>和<code>updateComponent</code>方法进行组件更新</li><li>如果在<code>shouldComponentUpdate</code>或者<code>componentWillUpdate</code>方法中调用<code>setState</code>，此时<code>this._pending-StateQueue != null</code>，就会造成循环调用，使得浏览器内存占满后崩溃</li></ul><p><strong>3 事务</strong></p><ul><li>事务就是将需要执行的方法使用<code>wrapper</code>封装起来，再通过事务提供的<code>perform</code>方法执行，先执行<code>wrapper</code>中的<code>initialize</code>方法，执行完<code>perform</code>之后，在执行所有的<code>close</code>方法，一组<code>initialize</code>及<code>close</code>方法称为一个<code>wrapper</code>。</li><li>那么事务和<code>setState</code>方法的不同表现有什么关系，首先我们把<code>4</code>次<code>setStat</code>e简单归类，前两次属于一类，因为它们在同一调用栈中执行，<code>setTimeout</code>中的两次<code>setState</code>属于另一类</li><li>在<code>setState</code>调用之前，已经处在<code>batchedUpdates</code>执行的事务中了。那么这次<code>batchedUpdates</code>方法是谁调用的呢，原来是<code>ReactMount.js</code>中的<code>_renderNewRootComponent</code>方法。也就是说，整个将<code>React</code>组件渲染到<code>DOM</code>中的过程就是处于一个大的事务中。而在<code>componentDidMount</code>中调用<code>setState</code>时，<code>batchingStrategy</code>的<code>isBatchingUpdates</code>已经被设为了<code>true</code>，所以两次<code>setState</code>的结果没有立即生效</li><li>再反观<code>setTimeout</code>中的两次<code>setState</code>，因为没有前置的<code>batchedUpdates</code>调用，所以导致了新的<code>state</code>马上生效</li></ul><p><strong>4. 总结</strong></p><ul><li>通过<code>setState</code>去更新<code>this.state</code>，不要直接操作<code>this.state</code>，请把它当成不可变的</li><li>调用<code>setState</code>更新<code>this.state</code>不是马上生效的，它是异步的，所以不要天真以为执行完<code>setState</code>后<code>this.state</code>就是最新的值了</li><li>多个顺序执行的<code>setState</code>不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行，即批处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v5和v6的区别对比</title>
      <link href="/2021/12/05/v5%E5%92%8Cv6%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/"/>
      <url>/2021/12/05/v5%E5%92%8Cv6%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>以下是两个版本之间的区别：</p><h2 id="一、首先是注册路由的时候v5的Switch改为了Routes"><a href="#一、首先是注册路由的时候v5的Switch改为了Routes" class="headerlink" title="一、首先是注册路由的时候v5的Switch改为了Routes"></a>一、首先是注册路由的时候v5的Switch改为了Routes</h2><p>v5，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123;<span class="title class_">Route</span>, <span class="title class_">Switch</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span> <span class="comment">//引入react-router</span></span><br><span class="line"> </span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 注册路由（编写路由链接） */</span>&#125;</span><br><span class="line">    &lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">    &lt;/<span class="title class_">Switch</span>&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>v6，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123;<span class="title class_">Route</span>, <span class="title class_">Routes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span> <span class="comment">//引入react-router</span></span><br><span class="line"> </span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 注册路由（编写路由链接） */</span>&#125;</span><br><span class="line">    &lt;<span class="title class_">Routes</span> &gt;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">    &lt;/<span class="title class_">Routes</span>&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="二、v6不再支持用Route标签包裹子组件，可以直接使用element属性-也不需要"><a href="#二、v6不再支持用Route标签包裹子组件，可以直接使用element属性-也不需要" class="headerlink" title="二、v6不再支持用Route标签包裹子组件，可以直接使用element属性 也不需要"></a>二、v6不再支持用Route标签包裹子组件，可以直接使用element属性 也不需要</h2><p>v5，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123;<span class="title class_">Route</span>, <span class="title class_">Switch</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span> <span class="comment">//引入react-router</span></span><br><span class="line"> </span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 注册路由（编写路由链接） */</span>&#125;</span><br><span class="line">    &lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">About</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">Switch</span>&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>v6，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123;<span class="title class_">Route</span>, <span class="title class_">Routes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span> <span class="comment">//引入react-router</span></span><br><span class="line"> </span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 注册路由（编写路由链接） */</span>&#125;</span><br><span class="line">    &lt;<span class="title class_">Routes</span> &gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">    &lt;/<span class="title class_">Routes</span>&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 如果v5不用包裹子组件的形式写的话他的属性是component，下面代码有体现到。</p><h2 id="三、v6中也不需要exact属性"><a href="#三、v6中也不需要exact属性" class="headerlink" title="三、v6中也不需要exact属性"></a>三、v6中也不需要exact属性</h2><p>exact在v5中起到的作用是精准匹配的作用，如果不写的话，</p><p>那么  **path=’/‘<strong>也会匹配</strong>‘/about’<strong>和</strong>‘/home’**导致的结果就是下面两个路由就没用了</p><p>在v6中由于v6 内部算法改变，它默认就是匹配完整路径。</p><p>v5，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123;<span class="title class_">Route</span>, <span class="title class_">Switch</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span> <span class="comment">//引入react-router</span></span><br><span class="line"> </span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 注册路由（编写路由链接） */</span>&#125;</span><br><span class="line">    &lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>  <span class="attr">component</span>=<span class="string">&#123;</span> <span class="attr">Home</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">Switch</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> v6，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123;<span class="title class_">Route</span>, <span class="title class_">Routes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span> <span class="comment">//引入react-router</span></span><br><span class="line"> </span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 注册路由（编写路由链接） */</span>&#125;</span><br><span class="line">    &lt;<span class="title class_">Routes</span> &gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">    &lt;/<span class="title class_">Routes</span>&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="四、v6-中，Route-先后顺序不再重要，它能够自动找出最优匹配路径"><a href="#四、v6-中，Route-先后顺序不再重要，它能够自动找出最优匹配路径" class="headerlink" title="四、v6 中，Route 先后顺序不再重要，它能够自动找出最优匹配路径"></a>四、v6 中，Route 先后顺序不再重要，它能够自动找出最优匹配路径</h2><h2 id="五、在v6中移除了NavLink中的actionclassName的这个属性"><a href="#五、在v6中移除了NavLink中的actionclassName的这个属性" class="headerlink" title="五、在v6中移除了NavLink中的actionclassName的这个属性"></a>五、在v6中移除了NavLink中的actionclassName的这个属性</h2><p>actionclassName这个属性是点击对应元素改变为对应的样式</p><p>在v6中可以使用三元运算符的方式实现这个功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span> className=&#123;<span class="function"><span class="params">navData</span>=&gt;</span>navData.<span class="property">isActive</span>?<span class="keyword">class</span>.<span class="property">active</span> : <span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="六、在v6中将Redirect改为Navigate"><a href="#六、在v6中将Redirect改为Navigate" class="headerlink" title="六、在v6中将Redirect改为Navigate"></a>六、在v6中将Redirect改为Navigate</h2><p>它当匹配不到路由时，需要使用Redirect做重定向，跳转到我们定义的组件（页面）中</p><p>v5，代码如下</p><p>在页面中直接写入重定向的路径</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Redirect</span> to=<span class="string">&quot;/home/&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>v6，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/&quot;</span> element =&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">replace</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="七、v6-嵌套路由改为相对匹配，不再像-v5-那样必须提供完整路径。"><a href="#七、v6-嵌套路由改为相对匹配，不再像-v5-那样必须提供完整路径。" class="headerlink" title="七、v6 嵌套路由改为相对匹配，不再像 v5 那样必须提供完整路径。"></a>七、v6 嵌套路由改为相对匹配，不再像 v5 那样必须提供完整路径。</h2><h2 id="八、新增Outelt组件"><a href="#八、新增Outelt组件" class="headerlink" title="八、新增Outelt组件"></a>八、新增Outelt组件</h2><p>此组件是一个占位符，告诉 React Router 嵌套的内容应该放到哪里。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/home2&quot;</span>&gt;子路由&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">Outlet</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="九、v6-用useNavigate实现编程式导航，不再使用useHistory"><a href="#九、v6-用useNavigate实现编程式导航，不再使用useHistory" class="headerlink" title="九、v6 用useNavigate实现编程式导航，不再使用useHistory"></a>九、v6 用useNavigate实现编程式导航，不再使用useHistory</h2><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useNavigate&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&quot;/home&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>是除此之外，还可以使用navigate<code>(-1)</code> 后退到前一页，使用navigate<code>-2)</code>后退到前一页的前一页， navigate<code>(1)</code>前向导航，依此类推</p><h1 id="十、v6-目前没有prompt组件阻止不期望的导航。"><a href="#十、v6-目前没有prompt组件阻止不期望的导航。" class="headerlink" title="十、v6 目前没有prompt组件阻止不期望的导航。"></a>十、v6 目前没有prompt组件阻止不期望的导航。</h1><p>如果在 v6 中要实现相应的功能，必须自己想办法，这可能是目前 v5 唯一的优势。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue3响应式原理</title>
      <link href="/2021/05/01/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2021/05/01/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>vue3.x改用proxy代替object.defineProperty。因为proxy可以直接监听对象和数组的变化，并且有多达13中拦截方法。并且作为新标准手袋浏览器厂商重点持续的性能优化。</p><p>proxy只会代理对象的第一层，那么vue3又是怎样处理这个问题的呢？</p><p>判断当前Reflect.get的返回值是否为object，如果是则再通过reactive方法做代理，这样就实现了深度观测。</p><p><strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong></p><p>我们可以判读key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 实例</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 当访问 vm 的成员会执行</span></span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get, key: &#x27;</span>, key, target[key])</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置 vm 的成员会执行</span></span><br><span class="line">  set (target, key, newValue) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set, key: &#x27;</span>, key, newValue)</span><br><span class="line">    <span class="keyword">if</span> (target[key] === newValue) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = newValue</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.<span class="property">msg</span> = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">msg</span>)</span><br></pre></td></tr></table></figure><p><strong>Proxy 相比于 defineProperty 的优势</strong></p><ul><li>数组变化也能监听到</li><li>不需要深度遍历监听</li></ul><p><code>Proxy</code> 是 <code>ES6</code> 中新增的功能，可以用来自定义对象中的操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// `target` 代表需要添加代理的对象</span></span><br><span class="line"><span class="comment">// `handler` 用来自定义对象中的操作</span></span><br><span class="line"><span class="comment">// 可以很方便的使用 Proxy 来实现一个数据绑定和监听</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">onWatch</span> = (<span class="params">obj, setBind, getLogger</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">      <span class="title function_">getLogger</span>(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">      <span class="title function_">setBind</span>(value);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, property, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">onWatch</span>(obj, <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  value = v</span><br><span class="line">&#125;, <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Get &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// bind `value` to `2`</span></span><br><span class="line">p.<span class="property">a</span> <span class="comment">// -&gt; Get &#x27;a&#x27; = 2</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p><img src="/2021/05/01/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/20210408091523.png"></p><ul><li>Vue<ul><li>记录传入的选项，设置 <code>$data/$el</code></li><li>把 <code>data</code> 的成员注入到 <code>Vue</code> 实例</li><li>负责调用 <code>Observer</code> 实现数据响应式处理(数据劫持)</li><li>负责调用 <code>Compiler</code> 编译指令/插值表达式等</li></ul></li><li>Observer<ul><li>数据劫持<ul><li>负责把 <code>data</code> 中的成员转换成 <code>getter/setter</code></li><li>负责把多层属性转换成 <code>getter/setter</code></li><li>如果给属性赋值为新对象，把新对象的成员设置为 <code>getter/setter</code></li></ul></li><li>添加 <code>Dep</code> 和 <code>Watcher</code> 的依赖关系</li><li>数据变化发送通知</li></ul></li><li>Compiler<ul><li>负责编译模板，解析指令/插值表达式</li><li>负责页面的首次渲染过程</li><li>当数据变化后重新渲染</li></ul></li><li>Dep<ul><li>收集依赖，添加订阅者(<code>watcher</code>)</li><li>通知所有订阅者</li></ul></li><li>Watcher<ul><li>自身实例化的时候往<code>dep</code>对象中添加自己</li><li>当数据变化<code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive实现原理</title>
      <link href="/2020/01/18/keep-alive%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/18/keep-alive%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>keep-alive<code>组件接受三个属性参数：</code>include<code>、</code>exclude<code>、</code>max</p></blockquote><ul><li><code>include</code> 指定需要缓存的<code>组件name</code>集合，参数格式支持<code>String, RegExp, Array。</code>当为字符串的时候，多个组件名称以逗号隔开。</li><li><code>exclude</code> 指定不需要缓存的<code>组件name</code>集合，参数格式和include一样。</li><li><code>max</code> 指定最多可缓存组件的数量,超过数量删除第一个。参数格式支持String、Number。</li></ul><p><strong>原理</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keep-alive`实例会缓存对应组件的`VNode`,如果命中缓存，直接从缓存对象返回对应`VNode</span><br></pre></td></tr></table></figure><p><code>LRU（Least recently used）</code> 算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。(墨菲定律：越担心的事情越会发生)</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何利用webpack来优化前端性能？（提高性能和体验）!</title>
      <link href="/2019/09/30/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F%EF%BC%88%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E4%BD%93%E9%AA%8C%EF%BC%89/"/>
      <url>/2019/09/30/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F%EF%BC%88%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E4%BD%93%E9%AA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能<br>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至崩溃<br>一般项目在完成后，会通过webpack进行打包，利用webpack对 前端项目性能优化是一个十分重要的环节</p><p>通过webpack优化前端的手段有：<br>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p><p>● JS压缩代码。</p><p>删除多余的代码、注释、简化代码的写法等等方式。</p><p>terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小 在production模式下，webpack默认使用Terser</p><p>可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css<br>● 利用CDN加速。</p><p>在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径<br>● 删除死代码（Tree Shaking）。</p><p>将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现</p><p>●Code Splitting。</p><p>将代码路由维度或者组件分块（chunk），这样做到 按需加载，同时可以充分利用浏览器缓存</p><p>● 提取公共第三方库。 </p><p>SplitChunkpligin插件来进行公共模块抽取，利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是bundle,chunk,module</title>
      <link href="/2019/08/27/%E4%BB%80%E4%B9%88%E6%98%AFbundle-chunk-module/"/>
      <url>/2019/08/27/%E4%BB%80%E4%B9%88%E6%98%AFbundle-chunk-module/</url>
      
        <content type="html"><![CDATA[<p>bundle：是由webpack打包出来的文件</p><p>chunk：是指webpack在进行模块依赖分析的时候，代码分割出来的代码块</p><p>module：是开发中的单个模块</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端代码为何要进行构建和打包</title>
      <link href="/2019/07/27/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BD%95%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA%E5%92%8C%E6%89%93%E5%8C%85/"/>
      <url>/2019/07/27/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BD%95%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA%E5%92%8C%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>1、代码方面体积更小，加载更快（tree-shaking，压缩合并）</p><p>​        编译高级语言和语法（ts，es6，模块化）</p><p>​        兼容性和错误提示（polyfill，postcss，eslint）</p><p>2、研发流程统一、高效的开发环境</p><p>​        统一的构建流程和产出标准</p><p>​        集成公司构建规范（提测，上线）</p><p>打包之后许多零碎的文件打包成一个整体，页面值需请求一次，js文件中使用模块化互相引用，这样能在一定程度上提供页面渲染效率，打包的同时会进行编译，将es6，sass等高级异发进行转换编译，以兼容高版本的浏览器</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>描述一下webpack中loader和plugin的思路</title>
      <link href="/2019/06/27/%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bwebpack%E4%B8%ADloader%E5%92%8Cplugin%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/2019/06/27/%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bwebpack%E4%B8%ADloader%E5%92%8Cplugin%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>loader像一个“翻译官”把读到的源文件内容转义成新的文件内容，并且每个loader通过链式 操作 ，将源文件一步步翻译成想要的样子。</p><p>编写loader时要遵循单一原则，每个loader只做一种“转义”工作。每个loader拿到的是源文件内容，可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法 ，将内容返回给webpack。还可以通过this.async生成一个callback函数，再用这个callback将处理后的内容输出出去。此外webpack还为开发者 准备了开发loader 的工具函数 集 ——loader-utils。</p><p>相对于loader而言，plugin的编写就灵活了许多。webpack在运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>connect原理</title>
      <link href="/2019/06/04/connect%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/04/connect%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="connect原理分析"><a href="#connect原理分析" class="headerlink" title="connect原理分析"></a>connect原理分析</h3><h4 id="1、connect用法"><a href="#1、connect用法" class="headerlink" title="1、connect用法"></a>1、connect用法</h4><p>作用：连接react组件与redux store</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">connect</span>([mapStateToProps], [mapDispatchToProps], [mergeProps],[options])</span><br><span class="line"><span class="comment">// 这个函数允许我们将 store 中的数据作为 props 绑定到组件上</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: state.<span class="property">count</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的第一个参数就是redux的store，我们从摘取了count属性，你不必将state中的数据原封不动地传入组件，可以根据state中的数据，动态地输出组件需要的（最小）属性</p><p>函数的第二个参数ownProps，是组件自己的props</p><p>当state变化，或者ownProps变化的时候，mapStateToProps都会被调用，计算出一个新的stateprops,(在与OwnProps merge后)更新给组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mapDispatchToProps</span>(dispatch, ownProps): dispatchProps</span><br></pre></td></tr></table></figure><p>之所以connect的成功是因为provider组件</p><p>在原应用组件上包裹了一层provider，使原来整个应用成为provider的子组件</p><p>接收redux的store作为props，通过context对象传递给子孙组件上的connect</p><p><strong>connect做了些什么</strong></p><blockquote><p>它真正连接 <code>Redux</code> 和 <code>React</code>，它包在我们的容器组件的外一层，它接收上面 <code>Provider</code>提供的 <code>store</code> 里面的 <code>state</code>和 <code>dispatch</code>，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件</p></blockquote><p><strong>源码</strong></p><p>connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产Component的函数(warpwithConnect),然后再将真正的Component作为参数传入wrapWithConnect,这样就生产出一个经过包裹的Connent组件</p><ul><li>通过<code>props.store</code>获取祖先<code>Component</code>的<code>store props</code>包括<code>stateProps</code>、<code>dispatchProps</code>、<code>parentProps</code>,合并在一起得到<code>nextState</code>，作为<code>props</code>传给真正的<code>Component</code></li><li><code>componentDidMount</code>时，添加事件<code>this.store.subscribe(this.handleChange)</code>，实现页面交互</li><li><code>shouldComponentUpdate</code>时判断是否有避免进行渲染，提升页面性能，并得到<code>nextState</code></li><li><code>componentWillUnmount</code>时移除注册的事件<code>this.handleChange</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Connect</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">        <span class="comment">// 从祖先Component处获得store</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">store</span> = props.<span class="property">store</span> || context.<span class="property">store</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stateProps</span> = <span class="title function_">computeStateProps</span>(<span class="variable language_">this</span>.<span class="property">store</span>, props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dispatchProps</span> = <span class="title function_">computeDispatchProps</span>(<span class="variable language_">this</span>.<span class="property">store</span>, props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">storeState</span>: <span class="literal">null</span> &#125;</span><br><span class="line">        <span class="comment">// 对stateProps、dispatchProps、parentProps进行合并</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateState</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">        <span class="comment">// 进行判断，当数据发生改变时，Component重新渲染</span></span><br><span class="line">        <span class="keyword">if</span> (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">updateState</span>(nextProps)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 改变Component的state</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">store</span>.<span class="title function_">subscribe</span>(() = &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">              <span class="attr">storeState</span>: <span class="variable language_">this</span>.<span class="property">store</span>.<span class="title function_">getState</span>()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 生成包裹组件Connect</span></span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.nextState</span>&#125; /&gt;</span></span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Connect</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">        <span class="attr">store</span>: storeShape</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Connect</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>loader和plugin的不同</title>
      <link href="/2019/05/27/loader%E5%92%8Cplugin%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
      <url>/2019/05/27/loader%E5%92%8Cplugin%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="不同的作用"><a href="#不同的作用" class="headerlink" title="不同的作用"></a>不同的作用</h3><p>loader直译为“加载器”。webpack将一切文件视为模块，但是webpack原生是只能解析JavaScript文件，如果想将其他文件打包的话，就会用到loader。所以loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</p><p>plugin直译为“插件”。plugin可以扩展webpack的功能，让webpack具有更多的 灵活性。在webpack运行的生命 周期广播出许多时间，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果 。</p><h3 id="不同的用法"><a href="#不同的用法" class="headerlink" title="不同的用法"></a>不同的用法</h3><p>1、loader在module rules中配置，也就是说他作为模块的解析规则而存在。类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载和使用的 参数</p><p>plugin在plugins中单独配置。类型是数组，每一项是一个plugin的实例，参数都通过构造函数传入。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue中的diff算法</title>
      <link href="/2019/05/22/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
      <url>/2019/05/22/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在新老虚拟DOM对比时</p><ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。 匹配时，找到相同的子节点，递归比较子节点</li></ul><blockquote><p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue渲染过程</title>
      <link href="/2019/05/21/vue%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/05/21/vue%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/21/vue%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/20210504211204.png"></p><ul><li>调用compile函数,生成 render 函数字符串 ,编译过程如下:<ul><li>parse 使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。<code>模板 -&gt; AST （最消耗性能）</code></li><li>optimize 遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，<code>优化runtime的性能</code></li><li>generate 将最终的AST转化为render函数字符串</li></ul></li><li>调用 <code>new Watcher</code> 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象</li><li>调用 <code>patch</code> 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue中template预编译</title>
      <link href="/2019/05/12/vue%E4%B8%ADtemplate%E9%A2%84%E7%BC%96%E8%AF%91/"/>
      <url>/2019/05/12/vue%E4%B8%ADtemplate%E9%A2%84%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h3 id="template预编译是什么"><a href="#template预编译是什么" class="headerlink" title="template预编译是什么"></a>template预编译是什么</h3><p>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。</p><blockquote><p>而模板编译的目的仅仅是将template转化为render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue2和vue3的区别</title>
      <link href="/2019/05/06/vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/05/06/vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<ul><li>重构响应式系统，使用Proxy替换Object.defineProperty，</li><li>使用Proxy优势：<ul><li>可直接监听数组类型的数据变化</li><li>监听的目标为对象本身，不需要像<code>Object.defineProperty</code>一样遍历每个属性，有一定的性能提升</li><li>可拦截<code>apply、ownKeys、has</code>等13种方法，而<code>Object.defineProperty</code>不行</li><li>直接实现对象属性的新增/删除</li></ul></li><li>新增<code>Composition API</code>，更好的逻辑复用和代码组织</li><li>重构Virtual DOM<ul><li>模板编译时的优化，将一些静态节点编译成常量</li><li><code>slot</code>优化，将<code>slot</code>编译为<code>lazy</code>函数，将<code>slot</code>的渲染的决定权交给子组件</li><li>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</li></ul></li><li>代码结构调整，更便于Tree shaking，使得体积更小</li><li>使用Typescript替换Flow</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack的优缺点</title>
      <link href="/2019/04/27/webpack%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2019/04/27/webpack%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="一、优点"><a href="#一、优点" class="headerlink" title="一、优点"></a>一、优点</h3><p>​    1、webpack是以commonJS的形式来书写脚本的，但对AMD/CMD的支持也很全面，方便旧项目进行代码迁移。</p><p>​    2、能被模块化的不仅是JS了</p><p>​    3、开发便捷，能替代部分grunt/gulp的工作，比如打包、压缩混淆、图片转base64等。</p><p>​    4、扩展性强，插件机制完善</p><h3 id="二、缺点"><a href="#二、缺点" class="headerlink" title="二、缺点"></a>二、缺点</h3><p>​    配置复杂</p><p>​    不分包bundle.js体积庞大</p><p>​    只能用于采用模块化开发的项目</p><p>​    打包慢</p><p>​    ES模块除Module外全用babel转换，但是一部分ES2015语法的firefox与chrome（谷歌）浏览器 中能直接跑的代码，无法用webpack编译</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack4和webpack5的区别</title>
      <link href="/2019/04/27/webpack4%E5%92%8Cwebpack5%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/04/27/webpack4%E5%92%8Cwebpack5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>更快的构建速度</p><p>更高的版本要求</p><p>更灵活的模块组合</p><p>更智能的缓存优化</p><p>更小的体积</p><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>webpack4上需要下载安装terser-webpack-plugin插件（代码压缩插件）</p><p>webpack5内部本身自带js压缩功能，它内置了该插件，我们就不用再下载安装。而且mode=“production”（生产模式）的时候会自动开启js压缩功能。</p><h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>webpack4缓存配置</p><p>npm install hard-source-webpack-plugin -D</p><p>webpack5缓存配置</p><p>webpack5内部内置了cache缓存机制，直接配置即可。</p><p>cache会在开发模式下被设置成type：memory而且会在生产模式把cache给禁用掉</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>webpack4启动服务</p><p>通过webpack-dev-server启动服务</p><p>webpack5启动服务</p><p>内置使用webpack serve启动，但是他的日志不是很好，所以一般都加都喜欢用webpack-dev-server优化</p><h3 id="devtool区别"><a href="#devtool区别" class="headerlink" title="devtool区别"></a>devtool区别</h3><p>sourceMap需要在webpack.config.js里面直接配置devtool就可以实现了。而devtool有很多个选项值，不同的选项值，不同的选项生产的map文件不同，打包速度不同。</p><p>一般情况下，我们一般在开发环境配置用chaap-eval-module-source-map，在生产环境用‘none’。</p><p>v4.devtool：cheap-eval-module-source-map</p><p>v5.devtool：eval-cheap-module-source-map</p><h3 id="打包："><a href="#打包：" class="headerlink" title="打包："></a>打包：</h3><p>​    webpack4打包：即使后续没有使用到num1的函数，依然会将代码打包进去</p><p>​    webpack5打包：后续没有使用到num1的函数，不会将代码打包进去</p><h3 id="输出代码："><a href="#输出代码：" class="headerlink" title="输出代码："></a>输出代码：</h3><p>​    webpack4只能输出es5的代码</p><p>​    webpack5新增属性output。ecmaVersion，可以生成ES5和ES6的代码</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是webpack，谈谈你对它的理解？</title>
      <link href="/2019/04/27/webpack/"/>
      <url>/2019/04/27/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>webpack是前端资源加载/打包的工具，它根据模块的依赖关系进行静态分析，然后根据指定的规则生成静态资源</p><h1 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h1><p>webpack可以将多种静态资源js，css，html等转换成一个静态文件，减少页面请求。</p><h1 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h1><h2 id="（1）核心概念"><a href="#（1）核心概念" class="headerlink" title="（1）核心概念"></a>（1）核心概念</h2><p>​                entry入口指示以哪个文件为入口起点开始打包，分析构建每部依赖图</p><p>​                output出口指示打包后的资源bundles输出到哪里以及命名</p><p>​                loader让webpack能够去处理哪些非JavaScript文件</p><p>​                plugin插件可以用于执行范围更广的任务，从打包优化和压缩，一直到重新定义环境中的变量</p><p>​                mode模式指示相应模式的配置</p><h2 id="（2）流程"><a href="#（2）流程" class="headerlink" title="（2）流程"></a>（2）流程</h2><p>​                流程是一个串行的过程，从启动到结束会依次执行：</p><p>​                初始化参数：从配置文件和shell语句中读取与合并参数，得出最终参数</p><p>​                开始编译：得到最终参数初始化和初始化complier对象，加载所有配置的插件，执行对象run方法开始编译</p><p>​                确定入口：根据配置的entry找到所有入口文件</p><p>​                编译模块：从入口文件出发，调用所有配置的loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理</p><p>​                完成编译：在经过第四步使用loader翻译完所有模块后，得到了每个模块翻译后的最终内容以及他们之间的依赖关系</p><p>​                输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</p><p>​                输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件 内容写入到文件 系统</p><p>webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用webpack提供的API改变webpack的运行结果</p><h2 id="（3）流程细节"><a href="#（3）流程细节" class="headerlink" title="（3）流程细节"></a>（3）流程细节</h2><p>​                    webpack的构建流程可以分为三个阶段：</p><p>​                        初始化：启动构建，读取与合并配置参数，加载plugin，实例化Complier对象</p><p>​                        编译：从entry出发，针对每个module串行调用对应的loder去翻译文件内容，再找到该mode依赖的mode，递归地进行编译处理。</p><p>​                         输出：对编译后的mode组合成chunk，把chunk转换成文件，输出到文件系统。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是React？</title>
      <link href="/2019/04/08/%E4%BB%80%E4%B9%88%E6%98%AFReact%EF%BC%9F/"/>
      <url>/2019/04/08/%E4%BB%80%E4%B9%88%E6%98%AFReact%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是React？"><a href="#什么是React？" class="headerlink" title="什么是React？"></a>什么是React？</h1><p>一、React简介<br>1、React是Facebook开发的一款JS库。</p><p>2、React一般被用来作为MVC中的V层，它不依赖其他任何的库，因此开发中，可以与任何其他的库集成使用，包括Jquery、Backbone等。</p><p>3、它可以在浏览器端运行，也可以通过nodejs在服务端渲染。</p><p>4、React的思想非常独特，性能出众，可以写出重复代码少，逻辑清晰的前端代码。</p><p>5、React的语法是jsx，通过使用这种语法，可以在react代码中直接混合使用js和html来编写代码，这样代码的逻辑就非常清晰，当然也意味着，需要将jsx代码编译成普通的javascript代码，才能在浏览器中运行，这个过程根据实际项目情况，可以选择多种不同的思路，或者在服务器端通过webpack进行编译。</p><p>二、React有什么特点？</p><p>1、 声明式设计 -React采用声明范式，可以轻松描述应用。</p><p>2、以组件的方式开发</p><p>3、使用特殊的jsx（JavaScript XML）语法</p><p>4.、高效 -React通过对DOM的模拟使用了虚拟DOM，最大限度地减少与DOM的交互。</p><p>什么是JSX？</p><div>        { this.state.s.title }        <ul>              {                this.state.list.map((item,index)=>{<pre><code>                  return &lt;li key=&#123; index &#125; &gt; &#123;  item  &#125; &lt;/li&gt;            &#125;)          &#125;      &lt;/ul&gt;</code></pre></ul></div><p>JSX是一种JavaScript的语法扩展，运用于React架构中，其格式比较像是模版语言，但事实上完全是在JavaScript内部实现的。元素是构成React应用的最小单位，JSX就是用来声明React当中的元素，React使用JSX来描述用户界面。</p><p>可以通过以下三个方面了解JSX：</p><p>1）JSX 是一种 JS 扩展的表达式<br>2）JSX 是带有逻辑的标记语法，有别于 HTML 模版<br>3）并且支持样式、逻辑表达式和事件</p><p>什么是虚拟DOM？<br>传统的 DOM 操作是直接在 DOM 上操作的，当需要修改一系列元素中的值时，就会直接对 DOM 进行操作。而采用 Virtual DOM 则会对需要修改的 DOM 进行比较（DIFF），从而只选择需要修改的部分。也因此对于不需要大量修改 DOM 的应用来说，采用 Virtual DOM 并不会有优势。开发者就可以创建出可交互的 UI。</p><p>在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。</p><p>虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。在实际开发中基本无需关心虚拟DOM是如何运作的，但是理解其运行机制不仅有助于更好的理解React组件的生命周期，而且对于进一步优化 React程序也会有很大帮助。</p><p>虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想</p><p>三、React有什么优缺点？<br>优点<br>1、React速度快、性能好<br>它并不直接对DOM进行操作，引入了一个叫做虚拟DOM的概念，安插在javascript逻辑和实际的DOM之间，性能好</p><p>2、跨浏览器兼容<br>虚拟DOM的原因帮助我们解决了跨浏览器问题，它为我们提供了标准化的API</p><p>3、单向数据流<br>Flux随着React视图库的开发而被Facebook概念化，是一个用于在JavaScript应用中创建单向数据层的架构</p><p>4、React兼容性好<br>使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。</p><p>缺点<br>1.并不是一个单独完整的框架<br>React是目标是UI组件，通常可以和其它框架组合使用，目前并不适合单独做一个完整的框架</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack的plugin</title>
      <link href="/2019/03/27/webpack%E7%9A%84plugin/"/>
      <url>/2019/03/27/webpack%E7%9A%84plugin/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Webpack-的-Plugin-是什么？"><a href="#一、Webpack-的-Plugin-是什么？" class="headerlink" title="一、Webpack 的 Plugin 是什么？"></a>一、Webpack 的 Plugin 是什么？</h3><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。</p><p>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等 。</p><h3 id="二、plugin的作用是什么？"><a href="#二、plugin的作用是什么？" class="headerlink" title="二、plugin的作用是什么？"></a>二、plugin的作用是什么？</h3><p>通过安装和配置第三方的插件，可以拓展webpack的能力，从而让webpack用起来更方便。最常用的webpack插件有：</p><p>1、webpack-dev-server</p><p>类似于node.js阶段用到的nodemon工具</p><p>每当修改了源代码，webpack会自动进行项目的打包和构建</p><p>2、html-webpack-plugin</p><p>webpack中的HTML插件（类似于一个模板引擎插件）</p><p>可以通过此 插件自定制index.html页面的内容</p><h3 id="三、有哪些常见的plugin？他们解决了什么问题？"><a href="#三、有哪些常见的plugin？他们解决了什么问题？" class="headerlink" title="三、有哪些常见的plugin？他们解决了什么问题？"></a>三、有哪些常见的plugin？他们解决了什么问题？</h3><ul><li>define-plugin：定义环境变量</li><li>commons-chunk-plugin：提取公共代码</li><li>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li><li>purgecss-webpack-plugin：擦除无用css</li><li>happypack：多线程处理打包</li><li>webpack-bundle-analyzer：打包分析</li><li>speed-measure-webpack-plugin：构建速度分析</li><li>html-webpack-plugin：</li><li>为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack的loader是什么？有什么作用？</title>
      <link href="/2019/03/27/webpack%E7%9A%84loader%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/"/>
      <url>/2019/03/27/webpack%E7%9A%84loader%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="Webpack-的-Loader-是什么？"><a href="#Webpack-的-Loader-是什么？" class="headerlink" title="Webpack 的 Loader 是什么？"></a>Webpack 的 Loader 是什么？</h3><p>webpack只能理解JavaScript和json文件，这是wepack开箱可用的自带能力。</p><p>loader可用让webpack能够去处理其他类型的文件，比如scss和ts，并将它们转换为有效的功能离散的chunk文件以供应用程序 使用，以及被添加到依赖图中，也可以将内联图像转换为data URL。简单来说，loader可以将一段代码转换成另一段代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。</p><p>loader从下到上地取值（evaluate）执行（execute），也就是是从后往前执行。在下面的示例中，从ts-loader开始执行，然后继续执行css-loader，最后以raw-loader为结束。loader有两个属性：test，正则表达式 ，用于识别出哪些文件会被转换，use定义在进行转换时应该使用哪个loader，可以是字符串 、数组和对象。</p><h3 id="有什么作用？"><a href="#有什么作用？" class="headerlink" title="有什么作用？"></a>有什么作用？</h3><p>webpack本身只能处理JavaScript和JSON，而loader为webpack添加了处理其他类型文件的能力。</p><p>webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉webpack在遇到哪些 文件时使用哪些loader去加载和转换打包成js。</p><p>注意：use属性的值需要是一个由Loader名称组成的数组，Loader的执行顺序是由后到前的；每一个loader都可以通过url querystring的方式传入参数，例如css-loader?minmize中的minmize告诉css-loader要开启css压缩。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack中有哪些常用的Loader？它们解决了什么问题？</title>
      <link href="/2019/03/25/webpack%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84Loader%EF%BC%9F%E5%AE%83%E4%BB%AC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
      <url>/2019/03/25/webpack%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84Loader%EF%BC%9F%E5%AE%83%E4%BB%AC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js事件机制</title>
      <link href="/2018/08/20/js%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/08/20/js%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？</p></blockquote><p><strong>1. 简介</strong></p><blockquote><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在<code>DOM</code>中两种不同的传播方法</p></blockquote><p><strong>事件流有三个阶段</strong></p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p><strong>事件捕获</strong></p><blockquote><p>事件捕获（<code>event capturing</code>）：通俗的理解就是，当鼠标点击或者触发<code>dom</code>事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p></blockquote><p><strong>事件冒泡</strong></p><blockquote><p>事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点</p></blockquote><p>无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播</p><p><img src="/2018/08/20/js%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/319.png"></p><p><strong>2. 捕获和冒泡</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    div1.<span class="property">onClick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    div2.<span class="property">onClick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当点击 <code>div2</code>时，会弹出两个弹出框。在 <code>ie8/9/10</code>、<code>chrome</code>浏览器，会先弹出”2”再弹出“1”，这就是事件冒泡：事件从最底层的节点向上冒泡传播。事件捕获则跟事件冒泡相反</p></blockquote><blockquote><p>W3C的标准是先捕获再冒泡， <code>addEventListener</code>的第三个参数决定把事件注册在捕获（<code>true</code>）还是冒泡(<code>false</code>)</p></blockquote><p><strong>3. 事件对象</strong></p><p><img src="/2018/08/20/js%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/320.png"></p><p><strong>4. 事件流阻止</strong></p><blockquote><p>在一些情况下需要阻止事件流的传播，阻止默认动作的发生</p></blockquote><ul><li><code>event.preventDefault()</code>：取消事件对象的默认动作以及继续传播。</li><li><code>event.stopPropagation()/ event.cancelBubble = true</code>：阻止事件冒泡。</li></ul><p><strong>事件的阻止在不同浏览器有不同处理</strong></p><ul><li>在<code>IE</code>下使用 <code>event.returnValue= false</code>，</li><li>在非<code>IE</code>下则使用 <code>event.preventDefault()</code>进行阻止</li></ul><p><strong>preventDefault与stopPropagation的区别</strong></p><ul><li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li><li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效</li></ul><p><strong>5. 事件注册</strong></p><ul><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code>。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">event.<span class="title function_">stopImmediatePropagation</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><strong>6. 事件委托</strong></p><ul><li>在<code>js</code>中性能优化的其中一个主要思想是减少<code>dom</code>操作。</li><li>节省内存</li><li>不需要给子节点注销事件</li></ul><blockquote><p>假设有<code>100</code>个<code>li</code>，每个<code>li</code>有相同的点击事件。如果为每<code>个Li</code>都添加事件，则会造成<code>dom</code>访问次数过多，引起浏览器重绘与重排的次数过多，性能则会降低。 使用事件委托则可以解决这样的问题</p></blockquote><p><strong>原理</strong></p><blockquote><p>实现事件委托是利用了事件的冒泡原理实现的。当我们为最外层的节点添加点击事件，那么里面的<code>ul</code>、<code>li</code>、<code>a</code>的点击事件都会冒泡到最外层节点上，委托它代为执行事件</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var ulEle = document.getElementById(&#x27;ul&#x27;);</span><br><span class="line">    ul.onclick = function(ev)&#123;</span><br><span class="line">        //兼容IE</span><br><span class="line">        ev = ev || window.event;</span><br><span class="line">        var target = ev.target || ev.srcElement;</span><br><span class="line">        </span><br><span class="line">        if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123;</span><br><span class="line">            alert( target.innerHTML);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期</title>
      <link href="/2018/07/02/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/07/02/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>s</p><h2 id="一、生命周期是什么"><a href="#一、生命周期是什么" class="headerlink" title="一、生命周期是什么"></a>一、生命周期是什么</h2><p>生命周期<code>（Life Cycle）</code>的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”<code>（Cradle-to-Grave）</code>的整个过程在<code>Vue</code>中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在<code>Vue</code>生命周期钩子会自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 <code>property</code> 和方法进行运算这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)</p><h2 id="二、生命周期有哪些"><a href="#二、生命周期有哪些" class="headerlink" title="二、生命周期有哪些"></a>二、生命周期有哪些</h2><p>Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p><table><thead><tr><th align="left">生命周期</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">beforeCreate</td><td align="left">组件实例被创建之初</td></tr><tr><td align="left">created</td><td align="left">组件实例已经完全创建</td></tr><tr><td align="left">beforeMount</td><td align="left">组件挂载之前</td></tr><tr><td align="left">mounted</td><td align="left">组件挂载到实例上去之后</td></tr><tr><td align="left">beforeUpdate</td><td align="left">组件数据发生变化，更新之前</td></tr><tr><td align="left">updated</td><td align="left">组件数据更新之后</td></tr><tr><td align="left">beforeDestroy</td><td align="left">组件实例销毁之前</td></tr><tr><td align="left">destroyed</td><td align="left">组件实例销毁之后</td></tr><tr><td align="left">activated</td><td align="left">keep-alive 缓存的组件激活时</td></tr><tr><td align="left">deactivated</td><td align="left">keep-alive 缓存的组件停用时调用</td></tr><tr><td align="left">errorCaptured</td><td align="left">捕获一个来自子孙组件的错误时被调用</td></tr></tbody></table><h2 id="三、生命周期整体流程"><a href="#三、生命周期整体流程" class="headerlink" title="三、生命周期整体流程"></a>三、生命周期整体流程</h2><p><code>Vue</code>生命周期流程图</p><p><img src="/2018/07/02/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20210408093135.png"></p><h4 id="具体分析"><a href="#具体分析" class="headerlink" title="#具体分析"></a><a href="https://vue3js.cn/interview/vue/lifecycle.html#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90">#</a>具体分析</h4><p><strong>beforeCreate -&gt; created</strong></p><ul><li>初始化<code>vue</code>实例，进行数据观测</li></ul><p><strong>created</strong></p><ul><li>完成数据观测，属性与方法的运算，<code>watch</code>、<code>event</code>事件回调的配置</li><li>可调用<code>methods</code>中的方法，访问和修改data数据触发响应式渲染<code>dom</code>，可通过<code>computed</code>和<code>watch</code>完成数据计算</li><li>此时<code>vm.$el</code> 并没有被创建</li></ul><p><strong>created -&gt; beforeMount</strong></p><ul><li>判断是否存在<code>el</code>选项，若不存在则停止编译，直到调用<code>vm.$mount(el)</code>才会继续编译</li><li>优先级：<code>render</code> &gt; <code>template</code> &gt; <code>outerHTML</code></li><li><code>vm.el</code>获取到的是挂载<code>DOM</code>的</li></ul><p><strong>beforeMount</strong></p><ul><li>在此阶段可获取到<code>vm.el</code></li><li>此阶段<code>vm.el</code>虽已完成DOM初始化，但并未挂载在<code>el</code>选项上</li></ul><p><strong>beforeMount -&gt; mounted</strong></p><ul><li>此阶段<code>vm.el</code>完成挂载，<code>vm.$el</code>生成的<code>DOM</code>替换了<code>el</code>选项所对应的<code>DOM</code></li></ul><p><strong>mounted</strong></p><ul><li><code>vm.el</code>已完成<code>DOM</code>的挂载与渲染，此刻打印<code>vm.$el</code>，发现之前的挂载点及内容已被替换成新的DOM</li></ul><p><strong>beforeUpdate</strong></p><ul><li>更新的数据必须是被渲染在模板上的（<code>el</code>、<code>template</code>、<code>rende</code>r之一）</li><li>此时<code>view</code>层还未更新</li><li>若在<code>beforeUpdate</code>中再次修改数据，不会再次触发更新方法</li></ul><p><strong>updated</strong></p><ul><li>完成<code>view</code>层的更新</li><li>若在<code>updated</code>中再次修改数据，会再次触发更新方法（<code>beforeUpdate</code>、<code>updated</code>）</li></ul><p><strong>beforeDestroy</strong></p><ul><li>实例被销毁前调用，此时实例属性与方法仍可访问</li></ul><p><strong>destroyed</strong></p><ul><li>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</li><li>并不能清除DOM，仅仅销毁实例</li></ul><p><strong>使用场景分析</strong></p><table><thead><tr><th align="left">生命周期</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">beforeCreate</td><td align="left">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td></tr><tr><td align="left">created</td><td align="left">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td></tr><tr><td align="left">beforeMount</td><td align="left">未执行渲染、更新，dom未创建</td></tr><tr><td align="left">mounted</td><td align="left">初始化结束，dom已创建，可用于获取访问数据和dom元素</td></tr><tr><td align="left">beforeUpdate</td><td align="left">更新前，可用于获取更新前各种状态</td></tr><tr><td align="left">updated</td><td align="left">更新后，所有状态已是最新</td></tr><tr><td align="left">beforeDestroy</td><td align="left">销毁前，可用于一些定时器或订阅的取消</td></tr><tr><td align="left">destroyed</td><td align="left">组件已销毁，作用同上</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nextTick作用与原理</title>
      <link href="/2018/07/02/nextTick/"/>
      <url>/2018/07/02/nextTick/</url>
      
        <content type="html"><![CDATA[<h3 id="作用：是为了可以获取更新后的DOM。"><a href="#作用：是为了可以获取更新后的DOM。" class="headerlink" title="作用：是为了可以获取更新后的DOM。"></a>作用：是为了可以获取更新后的DOM。</h3><p>由于vue DOM更新时异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了Vue.nextTick(),就是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取 更新后的DOM。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>nextTick可以让我们在下次DOM更新循环结束之后执行延迟回调，用于获取更新后的DOM</p><p>主要使用了宏任务和微任务。根据执行环境分别尝试采用</p><p>promise</p><p>MutationObserver</p><p>setimmediate</p><p>如果以上不都不行则采用setTimeout</p><p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><p>在写项目的时候，当时点击按钮要获取一个元素的内容，但是发现了第二次点击的时候才能获取到，后来在网上查了一下，发现是vue异步更新队列的问题，后来是通过$nextTick解决的。</p><p>应用场景：需要在视图更新之后，基于新的视图进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue2响应式原理</title>
      <link href="/2018/07/01/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/01/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>vue的响应式原理是核心通过ES5的保护对象object.defindeProperty中的访问器属性中的get和set方法，data中声明的属性都被添加了访问器属性，当读取data中的数据时自动调用get方法，当修改data中的数据时，自动调用set方法，检测到数据的变化，会通知观察者wacher，观察者wacher自动触发render当前 组件（子组件不会重新渲染），生成新的虚拟DOM数，vue框架会遍历并对比新虚拟DOM树和旧虚拟DOM树中每一个节点的差别，并 记录下来 ，最后，加载操作，将所有记录的不同点 ，局部修改到真实DOM树上。</p><p><img src="/2018/07/01/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/15.png"></p><p>虚拟DOM（Virtauil DOM）；用js对象模拟的，保存当前视图内所有DOM节点对象基本描述属性和节点间关系的数结构。用js对象，描述每个节点，及其父子关系，形成虚拟DOM对象结构。</p><p>因为只要在data中声明的基本数据类型的数据，基本不存在数据不响应问题，所以重点介绍数组和对象在vue中的数据响应问题，vue可以检测对象属性的修改，但无法监听数组的所有变动及对象的新增和删除，只能使用数组变异方法及$set方法。</p><p><img src="/2018/07/01/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/16.png"></p><p>可以看到，arrayMethods首先继承了Array，然后 对数组中所有能改变 数组自身的方法，如push，pop等这些方法进行重写。重写后的方法会执行它们本身原有的逻辑并对能增加数组长度的3个方法push、unshift、splice方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且在调用ob.dep.notify（）手动触发依赖通知 ，这就很好地解释了用vm.items.splice（newLength）方法可以检测到变化</p><p>总结：vue采用数据劫持结合发布—订阅模式的方法，通过object.defindeProperty（）来劫持各个属性setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p><img src="/2018/07/01/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/vue.jpeg"></p><ul><li><code>Observer</code> 遍历数据对象，给所有属性加上 <code>setter</code> 和 <code>getter</code>，监听数据的变化</li><li><code>compile</code> 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li></ul><blockquote><p><code>Watcher</code> 订阅者是 <code>Observer</code> 和 <code>Compile</code> 之间通信的桥梁，主要做的事情</p></blockquote><ul><li>在自身实例化时往属性订阅器 (<code>dep</code>) 里面添加自己</li><li>待属性变动 <code>dep.notice()</code> 通知时，调用自身的 <code>update()</code> 方法，并触发 <code>Compile</code> 中绑定的回调</li></ul><p>**Object.defineProperty()**，那么它的用法是什么，以及优缺点是什么呢？</p><ul><li>可以检测对象中数据发生的修改</li><li>对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。</li><li>对于一个对象中，如果你新增加属性，删除属性，**Object.defineProperty()**是不能观测到的，那么应该如何解决呢？可以通过<code>Vue.set()</code>和<code>Vue.delete()</code>来实现。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 的实例 </span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"><span class="comment">// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, <span class="string">&#x27;msg&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 可枚举(可遍历)</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) </span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 当获取值的时候执行 </span></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get: &#x27;</span>, data.<span class="property">msg</span>)</span><br><span class="line">    <span class="keyword">return</span> data.<span class="property">msg</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置值的时候执行 </span></span><br><span class="line">  set (newValue) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set: &#x27;</span>, newValue) </span><br><span class="line">    <span class="keyword">if</span> (newValue === data.<span class="property">msg</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    data.<span class="property">msg</span> = newValue</span><br><span class="line">    <span class="comment">// 数据更改，更新 DOM 的值 </span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = data.<span class="property">msg</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.<span class="property">msg</span> = <span class="string">&#x27;Hello World&#x27;</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">msg</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-router原理</title>
      <link href="/2018/06/02/vue-router/"/>
      <url>/2018/06/02/vue-router/</url>
      
        <content type="html"><![CDATA[<p><strong>vue-router</strong>是vue官方的路由管理器。它和vue.js的核心深度集成，让构建单页面应用变得易如反掌。vue-router默认是hash模式，还有一种是history模式。</p><p><strong>mode</strong></p><ul><li><code>hash</code></li><li><code>history</code></li></ul><p><strong>原理：</strong></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redux原理</title>
      <link href="/2018/05/18/redux%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/18/redux%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在 Redux 的整个工作过程中，数据流是严格单向的。这一点一定一定要背下来，面试的时候也一定一定要记得说</p><p>为什么要用redux</p><p>在React中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过props）,所以，两个非父子组件之间通信就相对麻烦，redux的出现就是为了解决state里面的数据问题</p><p>Redux设计理念</p><p>Redux是将整个应用状态存储到一个地方上称为store,里面保存着一个状态树store tree,组件可以派发(dispatch)行为(action)给store,而不是直接通知其他组件，组件内部通过订阅store中的状态state来刷新自己的视图</p><p><img src="/2018/05/18/redux%E5%8E%9F%E7%90%86/68.png"></p><p>如果你想对数据进行修改，<code>只有一种途径：派发 action</code>。action 会被 reducer 读取，进而根据 action 内容的不同对数据进行修改、生成新的 state（状态），这个新的 state 会更新到 store 对象里，进而驱动视图层面做出对应的改变。</p><p><strong>Redux三大原则</strong></p><ul><li>唯一数据源</li></ul><blockquote><p>整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中</p></blockquote><ul><li>保持只读状态</li></ul><blockquote><p><code>state</code>是只读的，唯一改变<code>state</code>的方法就是触发<code>action</code>，<code>action</code>是一个用于描述以发生时间的普通对象</p></blockquote><ul><li>数据改变只能通过纯函数来执行</li></ul><blockquote><p>使用纯函数来执行修改，为了描述<code>action</code>如何改变<code>state</code>的，你需要编写<code>reducers</code></p></blockquote><p><strong>从编码的角度理解 Redux 工作流</strong></p><ol><li>使用 <code>createStore 来完成 store 对象的创建</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 redux</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">    reducer,</span><br><span class="line">    initial_state,</span><br><span class="line">    <span class="title function_">applyMiddleware</span>(middleware1, middleware2, ...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>createStore 方法是一切的开始，它接收三个入参：</p><ul><li>reducer；</li><li>初始状态内容；</li><li>指定中间件</li></ul><ol><li><code>reducer 的作用是将新的 state 返回给 store</code></li></ol><p>一个 reducer 一定是一个纯函数，它可以有各种各样的内在逻辑，但它最终一定要返回一个 state：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 此处是各种样的 state处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> new_state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们基于某个 reducer 去创建 store 的时候，其实就是给这个 store 指定了一套更新规则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新规则全都写在 reducer 里 </span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer)</span><br></pre></td></tr></table></figure><ol><li>action 的作用是通知 reducer “让改变发生”</li></ol><blockquote><p>要想让 state 发生改变，就必须用正确的 action 来驱动这个改变。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;ADD_ITEM&quot;</span>,</span><br><span class="line">  <span class="attr">payload</span>: <span class="string">&#x27;&lt;li&gt;text&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>action 对象中允许传入的属性有多个，但只有 type 是必传的。type 是 action 的唯一标识，reducer 正是通过不同的 type 来识别出需要更新的不同的 state，由此才能够实现精准的“定向更新”。</p></blockquote><ol><li>派发 action，靠的是 dispatch</li></ol><p>action 本身只是一个对象，要想让 reducer 感知到 action，还需要“派发 action”这个动作，<code>这个动作是由 store.dispatch 完成的</code>。这里我简单地示范一下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">// 创建 reducer</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 此处是各种样的 state处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> new_state</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基于 reducer 创建 state</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer)</span><br><span class="line"><span class="comment">// 创建一个 action，这个 action 用 “ADD_ITEM” 来标识 </span></span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;ADD_ITEM&quot;</span>,</span><br><span class="line">  <span class="attr">payload</span>: <span class="string">&#x27;&lt;li&gt;text&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(action)</span><br></pre></td></tr></table></figure><p>以上这段代码，是从编码角度对 Redux 主要工作流的概括，这里我同样为你总结了一张对应的流程图：</p><p><img src="/2018/05/18/redux%E5%8E%9F%E7%90%86/20210426215948.png"></p><p><strong>Redux源码</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">createStore</span> = (<span class="params">reducer</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="comment">//获取状态对象</span></span><br><span class="line">    <span class="comment">//存放所有的监听函数</span></span><br><span class="line">    <span class="keyword">let</span> listeners = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">getState</span> = (<span class="params"></span>) =&gt; state;</span><br><span class="line">    <span class="comment">//提供一个方法供外部调用派发action</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dispath</span> = (<span class="params">action</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//调用管理员reducer得到新的state</span></span><br><span class="line">        state = <span class="title function_">reducer</span>(state, action);</span><br><span class="line">        <span class="comment">//执行所有的监听函数</span></span><br><span class="line">        listeners.<span class="title function_">forEach</span>(<span class="function">(<span class="params">l</span>) =&gt;</span> <span class="title function_">l</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//订阅状态变化事件，当状态改变发生之后执行监听函数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">subscribe</span> = (<span class="params">listener</span>) =&gt; &#123;</span><br><span class="line">        listeners.<span class="title function_">push</span>(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dispath</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispath,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">combineReducers</span>=(<span class="params">renducers</span>)=&gt;&#123;</span><br><span class="line">    <span class="comment">//传入一个renducers管理组，返回的是一个renducer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">state=&#123;&#125;,action=&#123;&#125;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> newState=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> renducers)&#123;</span><br><span class="line">            newState[attr]=renducers[attr](state[attr],action)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;createStore,combineReducers&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>react理解</title>
      <link href="/2018/05/17/react%E7%90%86%E8%A7%A3/"/>
      <url>/2018/05/17/react%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>React是一个用于构建用户界面的 JavaScript 库，提供了 UI 层面的解决方案</p><p>遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效</p><p>使用虚拟<code>DOM</code>来有效地操作<code>DOM</code>，遵循从高阶组件到低阶组件的单向数据流</p><p>帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面</p><p><code>react</code> 类组件使用一个名为 <code>render()</code> 的方法或者函数组件<code>return</code>，接收输入的数据并返回需要展示的内容</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello &#123;this.props.name&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage name=<span class="string">&quot;Taylor&quot;</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">&#x27;hello-example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述这种类似 <code>XML</code>形式就是<code>JSX</code>，最终会被<code>babel</code>编译为合法的<code>JS</code>语句调用</p><p>被传入的数据可在组件中通过 <code>this.props</code> 在 <code>render()</code> 访问</p><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p><code>React</code>特性有很多，如：</p><ul><li>JSX语法</li><li>单向数据绑定</li><li>虚拟DOM</li><li>声明式编程</li><li>Component</li></ul><p>着重介绍下声明式编程及Component</p><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做</p><p>它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件</p><p>如实现一个标记的地图：</p><p>通过命令式创建地图、创建标记、以及在地图上添加的标记的步骤如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建地图</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">map</span> = <span class="built_in">new</span> Map.<span class="keyword">map</span>(document.getElementById(<span class="string">&#x27;map&#x27;</span>), &#123;</span><br><span class="line">    zoom: <span class="number">4</span>,</span><br><span class="line">    center: &#123;lat,lng&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建标记</span></span><br><span class="line"><span class="keyword">const</span> marker = <span class="built_in">new</span> Map.marker(&#123;</span><br><span class="line">    position: &#123;lat, lng&#125;,</span><br><span class="line">    title: <span class="string">&#x27;Hello Marker&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地图上添加标记</span></span><br><span class="line">marker.setMap(<span class="keyword">map</span>);</span><br></pre></td></tr></table></figure><p>而用<code>React</code>实现上述功能则如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;Map zoom=&#123;<span class="number">4</span>&#125; center=&#123;lat, lng&#125;&gt;</span><br><span class="line">    &lt;Marker position=&#123;lat, lng&#125; title=&#123;<span class="string">&#x27;Hello Marker&#x27;</span>&#125;/&gt;</span><br><span class="line">&lt;/Map&gt;</span><br></pre></td></tr></table></figure><p>声明式编程方式使得<code>React</code>组件很容易使用，最终的代码简单易于维护</p><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>在<code>React</code> 中，一切皆为组件。通常将应用程序的整个逻辑分解为小的单个部分。我们将每个单独的部分称为组件</p><p>组件可以是一个函数或者是一个类，接受数据输入，处理它并返回在<code>UI</code>中呈现的<code>React</code>元素</p><p>函数式组件如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Jumbotron style=&#123;&#123;backgroundColor:<span class="string">&#x27;orange&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">            &lt;h1&gt;TODO App&lt;/h1&gt;</span><br><span class="line">        &lt;/Jumbotron&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件（有状态组件）如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class Dashboard extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line"></span><br><span class="line">        this.state = &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;dashboard&quot;</span>&gt; </span><br><span class="line">                &lt;ToDoForm /&gt;</span><br><span class="line">                &lt;ToDolist /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个组件该有的特点如下：</p><ul><li>可组合：个组件易于和其它组件一起使用，或者嵌套在另一个组件内部</li><li>可重用：每个组件都是具有独立功能的，它可以被使用在多个UI场景</li><li>可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</li></ul><h2 id="三、优势"><a href="#三、优势" class="headerlink" title="三、优势"></a>三、优势</h2><p>通过上面的初步了解，可以感受到<code>React</code>存在的优势：</p><ul><li>高效灵活</li><li>声明式的设计，简单使用</li><li>组件式开发，提高代码复用率</li><li>单向响应的数据流会比双向绑定的更安全，速度更快</li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>react的生命周期</title>
      <link href="/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>从出生到成长，最后到死亡，这个过程的时间可以理解为生命周期。React的生命周期同理也是这么一个过程。<br>React的生命周期分为三个阶段：挂载期（也叫实例化期）、更新期（也叫存在期）、卸载期（也叫销毁期）。在每个周期中React都提供了一些钩子函数。<br>生命周期的描述如下：<br>挂载期：一个组件实例初次被创建的过程。<br>更新期：组件在创建后再次渲染的过程。<br>卸载期：组件在使用完后被销毁的过程</p><h3 id="组件的挂载："><a href="#组件的挂载：" class="headerlink" title="组件的挂载："></a>组件的挂载：</h3><p>组件在首次创建后，进行第一次的渲染为挂载期。挂载期有的一些方法会被依次触发，列举如下：</p><p>constructor(构造函数，初始化状态值)<br>getInitialState(设置状态机)<br>getDefaultProps(获取默认的props)<br>UNSAFE_componentWillMount(首次渲染前执行)<br>render(渲染组件)<br>componentDidMount(render渲染之后执行的操作)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件挂载</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1,构造函数&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;&#125;;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2,设置状态机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> defaultProps=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;React&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params">nextProps, nextState, nextContext</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3,完成首次渲染前调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4,组件进行渲染&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5,componentDidMount render渲染后的操作&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20200910213725978.png"></p><h3 id="组件的更新："><a href="#组件的更新：" class="headerlink" title="组件的更新："></a>组件的更新：</h3><p>组件更新，指的是在组件初次渲染后，进行了组件状态的改变。React在生命周期中的更新过程包括以下几个方法：</p><p>UNSAFE_componentWillReceiveProps :当父组件更新子组件state时，该方法会被调用。<br>shouldComponentUpdate ： 该方法决定组件state或props的改变是否需要重新渲染组件。<br>UNSAFE_componentWillUpdate : 在组件接受新的state或者props时，即将进行重新渲染前调用该方法，和UNSAFE_componentWillMount方法类似。<br>componentDidUpdate : 在组件重新渲染后调用该方法，和componentDidMount方法类似。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件更新</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorldFather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">updateChildProps</span>=<span class="variable language_">this</span>.<span class="property">updateChildProps</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;  <span class="comment">//初始化父组件</span></span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;React&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">updateChildProps</span>(<span class="params"></span>)&#123;  <span class="comment">//更新父组件state</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;Vue&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">name</span>=<span class="string">&#123;this.state.name&#125;</span> /&gt;</span>  &#123;/*父组件的state传递给子组件*/&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.updateChildProps&#125;</span>&gt;</span>更新子组件props<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1,构造函数&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2,设置状态机&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3,完成首次渲染前调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillReceiveProps</span>(<span class="params">nextProps, nextContext</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;6,父组件更新子组件时调用该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState, nextContext</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;7,决定组件props或者state的改变是否需要重新进行渲染&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillUpdate</span>(<span class="params">nextProps, nextState, nextContext</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8,当接收到新的props或state时，调用该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4,组件进行渲染&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5,componentDidMount render后的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;9,组件被重新渲染后调用该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorldFather</span> /&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20200910215355814.png"></p><p>点击“更新子组件props”后：</p><p><img src="/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20200910215414998.png"></p><p><strong>组件的卸载：</strong><br>生命周期的最后一个过程为组件卸载期，也称为组件销毁期。该过程主要涉及一个 方法，即componentWillUnmount，当组件从DOM树删除的时候调用该方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件卸载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorldFather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">updateChildProps</span>=<span class="variable language_">this</span>.<span class="property">updateChildProps</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;  <span class="comment">//初始化父组件</span></span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;React&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">updateChildProps</span>(<span class="params"></span>)&#123;  <span class="comment">//更新父组件state</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;Vue&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">name</span>=<span class="string">&#123;this.state.name&#125;</span> /&gt;</span>  &#123;/*父组件的state传递给子组件*/&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.updateChildProps&#125;</span>&gt;</span>更新子组件props<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1,构造函数&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2,设置状态机&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3,完成首次渲染前调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillReceiveProps</span>(<span class="params">nextProps, nextContext</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;6,父组件更新子组件时调用该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState, nextContext</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;7,决定组件props或者state的改变是否需要重新进行渲染&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillUpdate</span>(<span class="params">nextProps, nextState, nextContext</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8,当接收到新的props或state时，调用该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">delComponent</span>(<span class="params"></span>)&#123;  <span class="comment">//添加卸载方法</span></span><br><span class="line">        <span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4,组件进行渲染&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.delComponent&#125;</span>&gt;</span>卸载组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  &#123;/*声明卸载按钮*/&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5,componentDidMount render后的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;9,组件被重新选然后调用该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;  <span class="comment">//组件卸载后执行</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;10,组件已被卸载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorldFather</span> /&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20200910220151124.png"></p><p>点击卸载按钮后：</p><p><img src="/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/2020091022022126.png"></p><p><strong>总览组件生命周期：</strong></p><p><img src="/2018/05/16/react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20200910204037223.png"></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js原型和原型链</title>
      <link href="/2018/05/03/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/05/03/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>1、构造函数<br>（1）<strong>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。</strong><br>我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。<br>（2）new 在执行时会做四件事情：<br>① 在内存中创建一个新的空对象。<br>② 让 this 指向这个新的对象。<br>③ 执行构造函数里面的代码，给这个新对象添加属性和方法。<br>④ 返回这个新对象（所以构造函数里面不需要 return ）。<br>2、静态成员和实例成员<br>（1）实例成员<br>实例成员就是构造函数内部通过this添加的成员，<strong>实例成员只能通过实例化的对象来访</strong><br>（2）静态成员<br>静态成员 在构造函数本身上添加的成员，<strong>静态成员只能通过构造函数来访问</strong><br>3、<strong>构造函数原型对象prototype</strong><br>（1）构造函数方法很好用，但是存在浪费内存的问题– 实例化构造函数调用里面函数，会为函数开辟单独的内存空间<br>（2）原型对象实现共享：公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上。<br>（3）<strong>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。</strong><br>注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。<br>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。<br>4、<strong>对象原型__proto__</strong><br>（1）<strong>对象都会有一个属性 proto 指向构造函数的 prototype 原型对象，</strong> 之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。<br>（2）**__proto__对象原型和原型对象 prototype 是等价的**<br>（3）__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype<br>5、<strong>原型constructor构造函数</strong><br>（1）<em>*对象原型（ proto）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性,我们称为构造函数，它指回构造函数本身。 **（2）**constructor 作用 – 记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</em>*<br>（3）一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。<br>注：<strong>如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</strong><br>（4）__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p><p>6、利用原型 – 扩展数组类（Array）的功能：<br>（1）为每一个数组对象添加一个方法，可以查找某个元素的所在位置<br>（2）调用find方法返回参数在数组中出现的位置<br>7、原型链<br>每一个实例对象又有一个proto属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有proto属性，这样一层一层往上找就形成了原型链。<br><img src="/2018/05/03/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/2196136-20210101140952621-845639098.png" alt="img"><br>8、构造函数实例和原型对象三角关系<br>（1）构造函数的prototype属性指向了构造函数原型对象<br>（2）实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象<br>（3）构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数<br>9、原型链和成员的查找机制<br>（1）当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。<br>（2）如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。<br>（3）如果还没有就查找原型对象的原型（Object的原型对象）。<br>（4）<strong>依此类推一直找到 Object 为止（null）</strong><br>（5）__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js实现继承的几种方法</title>
      <link href="/2018/05/02/js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/02/js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript实现继承的几种方法"><a href="#JavaScript实现继承的几种方法" class="headerlink" title="JavaScript实现继承的几种方法"></a>JavaScript实现继承的几种方法</h3><p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。</p><p><strong>在ES5中：</strong></p><p>既然要实现继承，那么首先我们得有一个父类</p><h4 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h4><p><strong>核心：</strong> 将父类的实例作为子类的原型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** es5 1.原型链继承 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;<span class="comment">//父类</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span> () &#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">a</span>()<span class="comment">//将子类原型对象等于实例化父类</span></span><br><span class="line"><span class="keyword">let</span> cha = <span class="keyword">new</span> <span class="title function_">b</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cha.<span class="property">age</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cha.<span class="property">name</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>核心原理：</strong></p><p>将子类所共享的方法提取出来，让子类的prototype原型对象=new 父类()</p><p>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</p><p><strong>优点：</strong>子类的实例可继承的属性—子类的实例的构造函数的属性、父类构造函数属性、父类原型的属性，但不会继承父类实例的属性</p><p><strong>缺点：</strong></p><p>​    1、在创建子类的实例时，不能向父类的构造函数中传递参数。严格来说，是没有办法在不影响所有对象实例的情况下，给父类的构造函数传递参数</p><p>​    2、所有子类的实例都会共享父类实例的属性：包含引用类型值的原型属性会被所有实例共享。</p><p>​    3、继承方式单一。</p><h4 id="2、构造函数继承"><a href="#2、构造函数继承" class="headerlink" title="2、构造函数继承"></a>2、构造函数继承</h4><p><strong>基本思想：</strong>通过call()或apply()方法在子类构造函数的内部调用父类构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** es5 2.构造函数继承 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">    a.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chb = <span class="keyword">new</span> <span class="title function_">b</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chb.<span class="property">age</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chb.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p><strong>实现的本质：</strong>在子类构造函数的内部调用超类型构造函数，使用aapply()和call() 方法</p><p><strong>优点：</strong></p><p>​    1、子类实例可以向父类构造函数传递参数</p><p>​    2、解决了包含引用类型值的原型属性会被所有实例共享的问题</p><p>​    3、使用call()或者apply可以同时继承多个构造函数的属性，解决了继承方式单一的问题</p><p><strong>缺点：</strong></p><p>​    1、只能继承父类构造函数的属性</p><p>​    2、每次使用都要重新调用，无法实现构造函数的复用。</p><p>​    3、每个子类实例都有父类构造函数的副本</p><h4 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h4><p><strong>基本思想：</strong>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** es5 3.组合式继承 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">    a.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">a</span>()</span><br><span class="line"><span class="keyword">let</span> chb = <span class="keyword">new</span> <span class="title function_">b</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chb.<span class="property">age</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chb.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><p>​    1、可以复用、也可以传参、还可以继承父类原型上的属性。</p><p>​    2、每个子类的实例引入的构造函数属性都是私有的。</p><p><strong>缺点：</strong>调用了两次父类构造函数，而且子类的构造函数会代替原型上的父类构造函数。</p><p><strong>在ES6中：</strong></p><p>​    class继承 通过extents关键字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** es6 extents */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Par</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Par</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c  = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">age</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vuex的原理</title>
      <link href="/2018/05/02/vuex/"/>
      <url>/2018/05/02/vuex/</url>
      
        <content type="html"><![CDATA[<p>vuex集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化。它集中于MVC模式中的Model层，规定所有数据操作必须通过 action - mutation - statechange 的流程来进行，再结合Vue的数据视图双向绑定特效来实现页面的展示更新。</p><p><img src="/2018/05/02/vuex/2150951-20200914181639511-333197550.png"></p><p>如图我们可以看到Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的api调用，vuex的简单分析：</p><p>　　　<strong>Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store，重新渲染Vue Components，页面随之更新。</strong></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>state：状态中心</p><p>mutations：更改状态</p><p>actions：异步更改状态</p><p>getters：获取状态</p><p>modules：将state分成多个modules，便于管理</p><h4 id="一-、状态-state"><a href="#一-、状态-state" class="headerlink" title="一 、状态-state"></a>一 、状态-state</h4><p>state保存应用状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123; <span class="attr">state</span>: &#123; <span class="attr">counter</span>:<span class="number">0</span> &#125;,&#125;)</span><br></pre></td></tr></table></figure><ol><li>状态变更 <strong>- mutations</strong></li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations`用于修改状态，`store.js</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">mutations</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">add</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span>++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ol><li>派生状态 <strong>- getters</strong></li></ol><blockquote><p>从state派生出新状态，类似计算属性</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">getters</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">doubleCounter</span>(<span class="params">state</span>) &#123; <span class="comment">// 计算剩余数量 return state.counter * 2;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ol><li>动作 <strong>- actions</strong></li></ol><p>加业务逻辑，类似于<code>controller</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">actions</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">add</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">        commit</span></span><br><span class="line"><span class="params">      &#125;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(() = &gt;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;add&#x27;)&quot;</span>&gt;</span>counter: &#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;$store.dispatch(&#x27;add&#x27;)&quot;</span>&gt;</span>async counter: &#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>double:&#123;&#123;$store.getters.doubleCounter&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>vuex原理解析</strong></p><ul><li><p>实现一个插件:声明<code>Store</code>类，挂载<code>$store</code></p></li><li><p>```<br>Store</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  具体实现:</span><br><span class="line"></span><br><span class="line">  - 创建响应式的`state`，保存`mutations`、`actions`和`getters`</span><br><span class="line">  - 实现`commit`根据用户传入`type`执行对应`mutation`</span><br><span class="line">  - 实现`dispatch`根据用户传入`type`执行对应`action`，同时传递上下文</span><br><span class="line">  - 实现`getters`，按照`getters`定义对`state`做派生</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// 目标1：实现Store类，管理state（响应式的），commit方法和dispatch方法</span><br><span class="line">// 目标2：封装一个插件，使用更容易使用</span><br><span class="line">let Vue;</span><br><span class="line"></span><br><span class="line">class Store &#123;</span><br><span class="line">  constructor(options) &#123;</span><br><span class="line">    // 定义响应式的state</span><br><span class="line">    // this.$store.state.xx</span><br><span class="line">    // 借鸡生蛋</span><br><span class="line">    this._vm = new Vue(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        $$state: options.state</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    this._mutations = options.mutations</span><br><span class="line">    this._actions = options.actions</span><br><span class="line"></span><br><span class="line">    // 绑定this指向</span><br><span class="line">    this.commit = this.commit.bind(this)</span><br><span class="line">    this.dispatch = this.dispatch.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 只读</span><br><span class="line">  get state() &#123;</span><br><span class="line">    return this._vm._data.$$state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set state(val) &#123;</span><br><span class="line">    console.error(&#x27;不能直接赋值呀，请换别的方式！！天王盖地虎！！&#x27;);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 实现commit方法，可以修改state</span><br><span class="line">  commit(type, payload) &#123;</span><br><span class="line">    // 拿出mutations中的处理函数执行它</span><br><span class="line">    const entry = this._mutations[type]</span><br><span class="line">    if (!entry) &#123;</span><br><span class="line">      console.error(&#x27;未知mutaion类型&#x27;);</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry(this.state, payload)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(type, payload) &#123;</span><br><span class="line">    const entry = this._actions[type]</span><br><span class="line"></span><br><span class="line">    if (!entry) &#123;</span><br><span class="line">      console.error(&#x27;未知action类型&#x27;);</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 上下文可以传递当前store实例进去即可</span><br><span class="line">    entry(this, payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function install(_Vue)&#123;</span><br><span class="line">  Vue = _Vue</span><br><span class="line"></span><br><span class="line">  // 混入store实例</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      if (this.$options.store) &#123;</span><br><span class="line">        Vue.prototype.$store = this.$options.store</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &#123; Store, install &#125;相当于Vuex</span><br><span class="line">// 它必须实现install方法</span><br><span class="line">export default &#123; Store, install &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js事件冒泡</title>
      <link href="/2017/08/06/js%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
      <url>/2017/08/06/js%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/08/06/js%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/20201123155129919.png"></p><p>点击box2后：</p><p><img src="/2017/08/06/js%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/Snipaste_2022-05-06_10-05-59.png"></p><p>分析：</p><p>因为box2在box1里面，所以点击box2时，也同时点击了box1，这就是<strong>事件冒泡</strong></p><p><strong>是从最具体的元素到不具体的元素（由内到外）</strong></p><p><strong>当子元素（事件源）事件触发，事件会沿着包含关系，依次往上级传递，每一级都可以感知到事件，直到触发根元素（根源)</strong></p><hr><p>上面例子的结果显然不是我们想要的， 我们希望的是点谁就显示谁，这时我们可以通过终止事件冒泡来得到我们想要的结果。</p><h3 id="终止事件冒泡"><a href="#终止事件冒泡" class="headerlink" title="终止事件冒泡"></a>终止事件冒泡</h3><p><strong>方法一：在相应的函数中加上event.stopPropagation()</strong></p><p><strong>方法二：判断event.target 和 event.currentTarget是否相等</strong></p><p>event.target：指真正触发事件的元素</p><p>event.currentTarget：指绑定了事件监听的元素（触发事件元素的父级元素）</p><p>这时判断两者相等，则执行相应的处理函数；当事件冒泡到上一级时，event.currentTarget变成 了上一级元素，这时候判断二者不相等，则就不作响应处理逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js事件委托</title>
      <link href="/2017/07/26/js%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2017/07/26/js%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<p>事件委托：利用事件冒泡的特性，将本应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现其本身没有相应事件就到父元素上寻找作出相应。</p><p>这样做的优势有：</p><p>1.减少DOM操作，提高性能。</p><p>2.随时可以添加子元素，添加的子元素会自动有相应的处理事件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用举例    </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> target = event.<span class="property">target</span>;</span><br><span class="line">  <span class="keyword">switch</span> (target.<span class="property">id</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;doSomething&quot;</span>:</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;事件委托&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;goSomewhere&quot;</span>:</span><br><span class="line">      location.<span class="property">href</span> = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;sayHi&quot;</span>: <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js防抖和节流</title>
      <link href="/2017/07/06/js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2017/07/06/js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<ul><li>函数防抖 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li><li>函数节流 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>,</span><br><span class="line">      nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js内存泄露</title>
      <link href="/2017/07/06/js%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2017/07/06/js%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<ul><li>意外的全局变量: 无法被回收</li><li>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</li><li>事件监听: 没有正确销毁 (低版本浏览器可能出现)</li><li>闭包<ul><li>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul></li><li><code>dom</code> 引用: <code>dom</code> 元素被删除时，内存中的引用未被正确清空</li><li>控制台<code>console.log</code>打印的东西</li></ul><blockquote><p>可用 <code>chrome</code> 中的 <code>timeline</code> 进行内存标记，可视化查看内存的变化情况，找出异常点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js垃圾回收</title>
      <link href="/2017/07/06/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2017/07/06/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<ul><li>对于在JavaScript中的字符串，对象，数组是没有固定大小的，只有当对他们进行动态分配存储时，解释器就会分配内存来存储这些数据，当JavaScript的解释器消耗完系统中所有可用的内存时，就会造成系统崩溃。</li><li>内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存越占越大，极端情况下可以导致系统崩溃，服务器宕机。</li><li>JavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。</li><li>针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数</li><li>标记清除</li></ul><blockquote><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p></blockquote><ul><li>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</li><li>新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。</li></ul><p><strong>这个算法分为三步：</strong></p><ul><li>首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</li><li>如果对象不存活，则释放对象的空间。</li><li>最后将 From 空间和 To 空间角色进行交换。</li></ul><p><strong>新生代对象晋升到老生代有两个条件：</strong></p><ul><li>第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老��代中；若没有经历，则复制到 To 空间。</li><li>第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</li></ul><blockquote><p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p></blockquote><p>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js深浅拷贝</title>
      <link href="/2017/06/06/js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2017/06/06/js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/06/06/js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/20210414142630.png"></p><p><strong>1. 浅拷贝的原理和实现</strong></p><blockquote><p>自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象</p></blockquote><p><strong>方法一：object.assign</strong></p><blockquote><p><code>object.assign</code>是 ES6 中 <code>object</code> 的一个方法，该方法可以用于 JS 对象的合并等多个用途，<code>其中一个用途就是可以进行浅拷贝</code>。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。</p></blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">object.assign 的语法为：Object.assign(target, ...sources)</span><br></pre></td></tr></table></figure><p>object.assign 的示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">// &#123; a: &#123; b: 1 &#125; &#125;;</span></span><br></pre></td></tr></table></figure><p><strong>但是使用 object.assign 方法有几点需要注意</strong></p><ul><li>它不会拷贝对象的继承属性；</li><li>它不会拷贝对象的不可枚举的属性；</li><li>可以拷贝 <code>Symbol</code> 类型的属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>:&#123; <span class="attr">b</span>:<span class="number">1</span> &#125;, <span class="attr">sym</span>:<span class="title class_">Symbol</span>(<span class="number">1</span>)&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj1, <span class="string">&#x27;innumerable&#x27;</span> ,&#123;</span><br><span class="line">    <span class="attr">value</span>:<span class="string">&#x27;不可枚举属性&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2,obj1)</span><br><span class="line">obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj2&#x27;</span>,obj2);</span><br></pre></td></tr></table></figure><blockquote><p>从上面的样例代码中可以看到，利用 <code>object.assign</code> 也可以拷贝 <code>Symbol</code> 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中<code>依旧存在着访问共同堆内存的问题</code>，也就是说<code>这种方法还不能进一步复制，而只是完成了浅拷贝的功能</code></p></blockquote><p><strong>方法二：扩展运算符方式</strong></p><ul><li>我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。</li><li>扩展运算符的语法为：<code>let cloneObj = &#123; ...obj &#125;;</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对象的拷贝 */</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj&#125;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)  <span class="comment">//&#123;a:2,b:&#123;c:1&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span></span><br><span class="line">obj.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)  <span class="comment">//&#123;a:2,b:&#123;c:2&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span></span><br><span class="line"><span class="comment">/* 数组的拷贝 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr]; <span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure><blockquote><p>扩展运算符 和 <code>object.assign</code> 有同样的缺陷，也就是<code>实现的浅拷贝的功能差不多</code>，但是如果属性都是<code>基本类型的值，使用扩展运算符进行浅拷贝会更加方便</code></p></blockquote><p><strong>方法三：concat 拷贝数组</strong></p><blockquote><p>数组的 <code>concat</code> 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 <code>concat</code> 只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">concat</span>();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [ 1, 100, 3 ]</span></span><br></pre></td></tr></table></figure><p><strong>方法四：slice 拷贝数组</strong></p><blockquote><p><code>slice</code> 方法也比较有局限性，因为<code>它仅仅针对数组类型</code>。<code>slice方法会返回一个新的数组对象</code>，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。</p></blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">slice 的语法为：arr.slice(begin, end);</span><br><span class="line">let arr = [1, 2, &#123;val: 4&#125;];</span><br><span class="line">let newArr = arr.slice();</span><br><span class="line">newArr[2].val = 1000;</span><br><span class="line">console.log(arr);  //[ 1, 2, &#123; val: 1000 &#125; ]</span><br></pre></td></tr></table></figure><blockquote><p>从上面的代码中可以看出，这就是<code>浅拷贝的限制所在了——它只能拷贝一层对象</code>。如果<code>存在对象的嵌套，那么浅拷贝将无能为力</code>。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝</p></blockquote><p><strong>手工实现一个浅拷贝</strong></p><p>根据以上对浅拷贝的理解，如果让你自己实现一个浅拷贝，大致的思路分为两点：</p><ul><li>对基础类型做一个最基本的一个拷贝；</li><li>对引用类型开辟一个新的存储，并且拷贝一层对象属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shallowClone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">          cloneTarget[prop] = target[prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用类型判断，针对引用类型的对象进行 for 循环遍历对象属性赋值给目标对象的属性，基本就可以手工实现一个浅拷贝的代码了</p></blockquote><p><strong>2. 深拷贝的原理和实现</strong></p><p><code>浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝</code>。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。</p><p>这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，<code>深拷贝的原理可以总结如下</code>：</p><blockquote><p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p></blockquote><p><strong>方法一：乞丐版（JSON.stringify）</strong></p><blockquote><p><code>JSON.stringify()</code> 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 <code>JSON</code> 的字符串，并将对象里面的内容转换成字符串，最后再用 <code>JSON.parse()</code> 的方法将 <code>JSON</code> 字符串生成一个新的对象</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">jobs</span>: &#123;</span><br><span class="line">        <span class="attr">first</span>: <span class="string">&#x27;FE&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a))</span><br><span class="line">a.<span class="property">jobs</span>.<span class="property">first</span> = <span class="string">&#x27;native&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">jobs</span>.<span class="property">first</span>) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure><p><strong>但是该方法也是有局限性的</strong>：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>无法拷贝不可枚举的属性</li><li>无法拷贝对象的原型链</li><li>拷贝 <code>RegExp</code> 引用类型会变成空对象</li><li>拷贝 <code>Date</code> 引用类型会变成字符串</li><li>对象中含有 <code>NaN</code>、<code>Infinity</code> 以及 <code>-Infinity</code>，<code>JSON</code> 序列化的结果会变成 <code>null</code></li><li>不能解决循环引用的对象，即对象成环 (<code>obj[key] = obj</code>)。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">func</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">1</span>) &#125;; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">und</span> = <span class="literal">undefined</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reg</span> = <span class="regexp">/123/</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">NaN</span> = <span class="title class_">NaN</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">infinity</span> = <span class="title class_">Infinity</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sym</span> = <span class="title class_">Symbol</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj1,<span class="string">&#x27;innumerable&#x27;</span>,&#123; </span><br><span class="line">  <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>:<span class="string">&#x27;innumerable&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1);</span><br><span class="line"><span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1);</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj2&#x27;</span>,obj2);</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>JSON.stringify</code> 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，<code>JSON.stringify</code> 暂时还是无法满足的，那么就需要下面的几种方法了</p></blockquote><p><strong>方法二：基础版（手写递归实现）</strong></p><blockquote><p>下面是一个实现 deepClone 函数封装的例子，通过 <code>for in</code> 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>:&#123;</span><br><span class="line">    <span class="attr">b</span>:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> cloneObj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;                 <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] ===<span class="string">&#x27;object&#x27;</span>) &#123; </span><br><span class="line">      cloneObj[key] = <span class="title function_">deepClone</span>(obj[key])  <span class="comment">//是对象就再次调用该函数递归</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cloneObj[key] = obj[key]  <span class="comment">//基本类型的话直接复制值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">deepClone</span>(obj1);</span><br><span class="line">obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2);   <span class="comment">//  &#123;a:&#123;b:1&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>虽然利用递归能实现一个深拷贝，但是同上面的 <code>JSON.stringify</code> 一样，还是有一些问题没有完全解决，例如：</p><ul><li>这个深拷贝函数并不能复制不可枚举的属性以及 <code>Symbol</code> 类型；</li><li>这种方法<code>只是针对普通的引用类型的值做递归复制</code>，而对于 <code>Array、Date、RegExp、Error、Function</code> 这样的引用类型并不能正确地拷贝；</li><li>对象的属性里面成环，即<code>循环引用没有解决</code>。</li></ul><p>这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是你在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。</p><p>所以为了“拯救”这些缺陷，下面我带你一起看看改进的版本，以便于你可以在面试种呈现出更好的深拷贝方法，赢得面试官的青睐。</p><p><strong>方法三：改进版（改进后递归实现）</strong></p><blockquote><p>针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。</p></blockquote><ul><li>针对能够遍历对象的不可枚举属性以及 <code>Symbol</code> 类型，我们可以使用 <code>Reflect.ownKeys</code> 方法；</li><li>当参数为 <code>Date、RegExp</code> 类型，则直接生成一个新的实例返回；</li><li>利用 <code>Object</code> 的 <code>getOwnPropertyDescriptors</code> 方法可以获得对象的所有属性，以及对应的特性，顺便结合 <code>Object.create</code> 方法创建一个新对象，并继承传入原对象的原型链；</li><li>利用 <code>WeakMap</code> 类型作为 <code>Hash</code> 表，因为 <code>WeakMap</code> 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 <code>Map</code> 和 <code>weakMap</code> 的关键区别，这里要用 <code>weakMap</code>），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 <code>WeakMap</code> 存储的值</li></ul><p>如果你在考虑到循环引用的问题之后，还能用 <code>WeakMap</code> 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了</p><p><strong>实现深拷贝</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isComplexDataType</span> = obj =&gt; (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> obj === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; (obj !== <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="keyword">function</span> (<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)       <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">RegExp</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)     <span class="comment">//正则对象直接返回一个新的正则对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果循环引用了就用 weakMap 来解决</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> allDesc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把cloneObj原型复制到obj上</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123; </span><br><span class="line">    cloneObj[key] = (<span class="title function_">isComplexDataType</span>(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">&#x27;function&#x27;</span>) ? <span class="title function_">deepClone</span>(obj[key], hash) : obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是验证代码</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">str</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">boolean</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">unf</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">nul</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;我是一个对象&#x27;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是一个函数&#x27;</span>) &#125;,</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>),</span><br><span class="line">  <span class="attr">reg</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;/我是一个正则/ig&#x27;</span>),</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&#x27;1&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;innumerable&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;不可枚举属性&#x27;</span> &#125;</span><br><span class="line">);</span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj))</span><br><span class="line">obj.<span class="property">loop</span> = obj    <span class="comment">// 设置loop成循环引用的属性</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="title function_">deepClone</span>(obj)</span><br><span class="line">cloneObj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj&#x27;</span>, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cloneObj&#x27;</span>, cloneObj)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js事件循环</title>
      <link href="/2017/05/18/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2017/05/18/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/05/18/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/20210516161332.png"></p><ul><li>默认代码从上到下执行，执行环境通过<code>script</code>来执行（宏任务）</li><li>在代码执行过程中，调用定时器 <code>promise</code> <code>click</code>事件…不会立即执行，需要等待当前代码全部执行完毕</li><li>给异步方法划分队列，分别存放到微任务（立即存放）和宏任务（时间到了或事情发生了才存放）到队列中</li><li><code>script</code>执行完毕后，会清空所有的微任务</li><li>微任务执行完毕后，会渲染页面（不是每次都调用）</li><li>再去宏任务队列中看有没有到达时间的，拿出来其中一个执行</li><li>执行完毕后，按照上述步骤不停的循环</li></ul><p><strong>1. 浏览器事件循环</strong></p><blockquote><p>涉及面试题：异步代码执行顺序？解释一下什么是 <code>Event Loop</code> ？</p></blockquote><blockquote><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</p></blockquote><blockquote><p>js代码执行过程中会有很多任务，这些任务总的分成两类：</p></blockquote><ul><li>同步任务</li><li>异步任务</li></ul><blockquote><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：</p></blockquote><p><img src="/2017/05/18/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/10.png"></p><p><strong>我们解释一下这张图：</strong></p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><blockquote><p>那主线程执行栈何时为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数</p></blockquote><p>以上就是js运行的整体流程</p><p><strong>面试中该如何回答呢？ 下面是我个人推荐的回答：</strong></p><ul><li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行</li><li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li>第一轮：主线程开始执行，遇到<code>setTimeout</code>，将setTimeout的回调函数丢到宏任务队列中，在往下执行<code>new Promise</code>立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到<code>process.nextTick</code>，同样将回调函数扔到微任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和<code>nextTick</code>两个微任务，先执行哪个呢？<code>process.nextTick</code>指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。</li><li>第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431</li></ul><blockquote><p><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</p></blockquote><p><img src="/2017/05/18/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/4.png"></p><p><strong>微任务</strong></p><ul><li><p><code>process.nextTick</code></p></li><li><p><code>promise</code></p></li><li><p><code>Object.observe</code></p></li><li><p>MutationObserver</p></li></ul><p><strong>宏任务</strong></p><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code> 网络请求完成、文件读写完成事件</li><li><code>UI rendering</code></li><li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li></ul><p><img src="/2017/05/18/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/20210414213126.png"></p><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><ul><li>JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务</li><li>执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</li><li>然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</li></ul><p><img src="/2017/05/18/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/20210414211816.png"></p><p>总结起来就是：<code>一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类型检测方法</title>
      <link href="/2017/05/05/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2017/05/05/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="类型检测的四种方式"><a href="#类型检测的四种方式" class="headerlink" title="类型检测的四种方式"></a>类型检测的四种方式</h3><h4 id="1-typeof-方法"><a href="#1-typeof-方法" class="headerlink" title="1.typeof 方法"></a>1.typeof 方法</h4><p>对于引用类型Arrary、Null、[]、{} 都会返回 object ,若对 object 无严格要求可以简单使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;hello&quot;</span>); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><ol start="2"><li><h4 id="instanceof-方法"><a href="#instanceof-方法" class="headerlink" title="instanceof 方法"></a>instanceof 方法</h4></li></ol><p>  不建议使用，问题有点多，尤其 null、undefined。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">//false</span></span><br><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>) <span class="keyword">instanceof</span> <span class="title class_">Number</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol start="3"><li><h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h4></li></ol><p>  不可检测 null、undefined</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1&quot;</span>.<span class="property">constructor</span> === <span class="title class_">String</span>; <span class="comment">//true</span></span><br><span class="line">[].<span class="property">constructor</span> === <span class="title class_">Array</span>; <span class="comment">//true</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;.<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line">(&#123;&#125;.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="literal">undefined</span>.<span class="property">constructor</span> === <span class="title class_">Undefined</span>; <span class="comment">//Uncaught TypeError: Cannot read property &#x27;constructor&#x27; of undefined</span></span><br><span class="line"><span class="comment">//构造函数的问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line">f.<span class="property">constructor</span> === <span class="title class_">Fn</span>; <span class="comment">//false</span></span><br><span class="line">f.<span class="property">constructor</span> === <span class="title class_">Array</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol start="4"><li><h4 id="Object-prototype-toString-call-方法"><a href="#Object-prototype-toString-call-方法" class="headerlink" title="Object.prototype.toString.call() 方法"></a>Object.prototype.toString.call() 方法</h4></li></ol><p>  所有的数据类型，这个办法都可以判断出来。返回结果为字符串类型，开头大些。注意：[object String]中间是有个空格的。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//[object String]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//String</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-和-typeof-的实现原理"><a href="#instanceof-和-typeof-的实现原理" class="headerlink" title="instanceof 和 typeof 的实现原理"></a>instanceof 和 typeof 的实现原理</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>原理：js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息</p><p>000：对象<br>010：浮点数<br>100：字符串<br>110：布尔<br>1：整数<br>特殊：undefined和null</p><p>null：所有机器码均为0<br>undefined：用 −2^30 整数来表示<br>typeof 在判断 null 的时候</p><p>由于 null 的所有机器码均为0，因此直接被当做了对象来看待。<br>null instanceof null 会 TypeError，直接被判断为不是 object。（ JavaScript 的历史遗留bug）<br>typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof 来判断对象的具体类型<br>instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ECMAScript 语言规范,`instanceof`原理基本思路</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> rightProto = rightVaule.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">   leftVaule = leftVaule.<span class="property">__proto__</span>; <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (leftVaule === <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       leftVaule = leftVaule.<span class="property">__proto__</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript This指向</title>
      <link href="/2017/04/26/This%E6%8C%87%E5%90%91/"/>
      <url>/2017/04/26/This%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不同情况的调用，<code>this</code>指向分别如何。顺带可以提一下 <code>es6</code> 中箭头函数没有 <code>this</code>, <code>arguments</code>, <code>super</code> 等，这些只依赖包含箭头函数最接近的函数</p></blockquote><blockquote><p>我们先来看几个函数调用的场景</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><ul><li>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是<code>window</code></li><li>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</li><li>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code></li></ul><blockquote><p>说完了以上几种情况，其实很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>()()())</span><br></pre></td></tr></table></figure><ul><li>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code>这类函数是无效的。</li><li>最后种情况也就是 <code>bind</code> 这些改变上下文的 <code>API</code> 了，对于这些函数来说，<code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</li><li>那么说到 <code>bind</code>，不知道大家是否考虑过，如果对一个函数进行多次 <code>bind</code>，那么上下文会是什么呢？</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;</span><br><span class="line">fn.<span class="title function_">bind</span>().<span class="title function_">bind</span>(a)() <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你认为输出结果是 <code>a</code>，那么你就错了，其实我们可以把上述代码转换成另一种形式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>()</span><br><span class="line">  &#125;.<span class="title function_">apply</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn2</span>()</span><br></pre></td></tr></table></figure><blockquote><p>可以从上述代码中发现，不管我们给函数 <code>bind</code> 几次，<code>fn</code> 中的 <code>this</code> 永远由第一次 <code>bind</code> 决定，所以结果永远是 <code>window</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;poetries&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">bind</span>(a)() <span class="comment">// =&gt; &#x27;poetries&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上就是 <code>this</code> 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p></blockquote><blockquote><p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p></blockquote><p><img src="https://s.poetries.work/gitee/2020/07/2.png" alt="image.png"></p><p><strong>函数执行改变this</strong></p><ul><li>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是<code>this</code>。</li></ul><blockquote><p>因此要明白 <code>this</code> 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如</p></blockquote><ul><li><code>obj.fn()</code>，便是 <code>obj</code> 调用了函数，既函数中的 <code>this === obj</code></li><li><code>fn()</code>，这里可以看成 <code>window.fn()</code>，因此 <code>this === window</code></li></ul><blockquote><p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p></blockquote><ul><li><code>call: fn.call(target, 1, 2)</code></li><li><code>apply: fn.apply(target, [1, 2])</code></li><li><code>bind: fn.bind(target)(1,2)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript类型及检测方式</title>
      <link href="/2017/04/26/boke01/"/>
      <url>/2017/04/26/boke01/</url>
      
        <content type="html"><![CDATA[<h3 id="1-JS内置类型"><a href="#1-JS内置类型" class="headerlink" title="1. JS内置类型"></a><strong>1. JS内置类型</strong></h3><p>JavaScript 的数据类型有下图所示</p><p><img src="/2017/04/26/boke01/20210414100319.png"></p><blockquote><p>其中，前 7 种类型为基础类型，最后 <code>1 种（Object）为引用类型</code>，也是你需要重点关注的，因为它在日常工作中是使用得最频繁，也是需要关注最多技术细节的数据类型</p></blockquote><ul><li><p><code>JavaScript</code>一共有8种数据类型，其中有7种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>（<code>es6</code>新增，表示独一无二的值）和<code>BigInt</code>（<code>es10</code>新增）；</p></li><li><p>1种引用数据类型——</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object</span><br></pre></td></tr></table></figure><p>（Object本质上是由一组无序的名值对组成的）。里面包含</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function、Array、Date</span><br></pre></td></tr></table></figure><p>等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</p><ul><li><strong>引用数据类型:</strong> 对象<code>Object</code>（包含普通对象-<code>Object</code>，数组对象-<code>Array</code>，正则对象-<code>RegExp</code>，日期对象-<code>Date</code>，数学函数-<code>Math</code>，函数对象-<code>Function</code>）</li></ul></li></ul><blockquote><p>在这里，我想先请你重点了解下面两点，因为各种 JavaScript 的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分成两类来进行存储：</p></blockquote><ul><li><strong>原始数据类型</strong>：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</li><li><strong>引用数据类型</strong>：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p><strong>JavaScript 中的数据是如何存储在内存中的？</strong></p><blockquote><p>在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p></blockquote><p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<code>代码空间</code>、<code>栈空间</code>、<code>堆空间</code>。其中的代码空间主要是存储可执行代码的，原始类型(<code>Number、String、Null、Undefined、Boolean、Symbol、BigInt</code>)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在”堆空间”中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p><p>在编译过程中，如果 JavaScript 引擎判断到一个闭包，也会在堆空间创建换一个<code>“closure(fn)”</code>的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存闭包中的变量。所以闭包中的变量是存储在“堆空间”中的。</p><p>JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。因此需要“栈”和“堆”两种空间。</p><blockquote><p>题目一：初出茅庐</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>);  <span class="comment">//第一个console</span></span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>);  <span class="comment">//第二个console</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>);  <span class="comment">//第三个console</span></span><br></pre></td></tr></table></figure><blockquote><p>这道题比较简单，我们可以看到第一个 console 打出来 name 是 ‘lee’，这应该没什么疑问；但是在执行了 b.name=’son’ 之后，结果你会发现 a 和 b 的属性 name 都是 ‘son’，第二个和第三个打印结果是一样的，这里就体现了引用类型的“共享”的特性，即这两个值都存在同一块内存中共享，一个发生了改变，另外一个也随之跟着变化。</p></blockquote><p>你可以直接在 Chrome 控制台敲一遍，深入理解一下这部分概念。下面我们再看一段代码，它是比题目一稍复杂一些的对象属性变化问题。</p><blockquote><p>题目二：渐入佳境</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  o.<span class="property">age</span> = <span class="number">24</span>;</span><br><span class="line">  o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">change</span>(a);     <span class="comment">// 注意这里没有new，后面new相关会有专门文章讲解</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>);    <span class="comment">// 第一个console</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>);    <span class="comment">// 第二个console</span></span><br></pre></td></tr></table></figure><p>这道题涉及了 <code>function</code>，你通过上述代码可以看到第一个 <code>console</code> 的结果是 <code>30</code>，<code>b</code> 最后打印结果是 <code>&#123;name: &quot;Kath&quot;, age: 30&#125;</code>；第二个 <code>console</code> 的返回结果是 <code>24</code>，而 <code>a</code> 最后的打印结果是 <code>&#123;name: &quot;Julia&quot;, age: 24&#125;</code>。</p><p>是不是和你预想的有些区别？你要注意的是，这里的 <code>function</code> 和 <code>return</code> 带来了不一样的东西。</p><blockquote><p>原因在于：函数传参进来的 <code>o</code>，传递的是对象在堆中的内存地址值，通过调用 <code>o.age = 24</code>（第 7 行代码）确实改变了 <code>a</code> 对象的 <code>age</code> 属性；但是第 12 行代码的 <code>return</code> 却又把 <code>o</code> 变成了另一个内存地址，将 <code>&#123;name: &quot;Kath&quot;, age: 30&#125;</code> 存入其中，最后返回 <code>b</code> 的值就变成了 <code>&#123;name: &quot;Kath&quot;, age: 30&#125;</code>。而如果把第 12 行去掉，那么 <code>b</code> 就会返回 <code>undefined</code></p></blockquote><h3 id="2-数据类型检测"><a href="#2-数据类型检测" class="headerlink" title="2. 数据类型检测"></a><strong>2. 数据类型检测</strong></h3><h4 id="（1）typeof"><a href="#（1）typeof" class="headerlink" title="（1）typeof"></a><strong>（1）typeof</strong></h4><blockquote><p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 `instanceof</span><br></pre></td></tr></table></figure></blockquote><h4 id="（2）instanceof"><a href="#（2）instanceof" class="headerlink" title="（2）instanceof"></a><strong>（2）instanceof</strong></h4><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure><ul><li><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li><li>而 <code>typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了 <code>function</code> 类型以外，其他的也无法判断</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们也可以试着实现一下 instanceof</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 获得类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="comment">// 获得对象的原型</span></span><br><span class="line">    left = left.<span class="property">__proto__</span></span><br><span class="line">    <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.<span class="property">__proto__</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）constructor"><a href="#（3）constructor" class="headerlink" title="（3）constructor"></a><strong>（3）constructor</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>这里有一个坑，如果我创建一个对象，更改它的原型，<code>constructor</code>就会变得不可靠了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h4 id="（4）Object-prototype-toString-call"><a href="#（4）Object-prototype-toString-call" class="headerlink" title="（4）Object.prototype.toString.call()"></a><strong>（4）Object.prototype.toString.call()</strong></h4><blockquote><p><code>toString()</code> 是 <code>Object</code> 的原型方法，调用该方法，可以统一返回格式为 <code>“[object Xxx]”</code> 的字符串，其中 <code>Xxx</code> 就是对象的类型。对于 <code>Object</code> 对象，直接调用 <code>toString()</code> 就能返回 <code>[object Object]</code>；而对于其他对象，则需要通过 <code>call</code> 来调用，才能返回正确的类型信息。我们来看一下代码。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)   <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/123/g</span>)    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])       <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>)  <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">window</span>)   <span class="comment">//&quot;[object Window]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></table></figure><blockquote><p>实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> type  = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;    <span class="comment">// 先进行typeof判断，如果是基础数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">replace</span>(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>);  <span class="comment">// 注意正则中间有个空格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */</span></span><br><span class="line"><span class="title function_">getType</span>([])     <span class="comment">// &quot;Array&quot; typeof []是object，因此toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="string">&#x27;123&#x27;</span>)  <span class="comment">// &quot;string&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="variable language_">window</span>) <span class="comment">// &quot;Window&quot; toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">null</span>)   <span class="comment">// &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">undefined</span>)   <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>()            <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) <span class="comment">// &quot;function&quot; typeof能判断，因此首字母小写</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="regexp">/123/g</span>)      <span class="comment">//&quot;RegExp&quot; toString返回</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><ul><li><p>```<br>typeof</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 直接在计算机底层基于数据类型的值（二进制）进行检测</span><br><span class="line">  - `typeof null`为`object` 原因是对象存在在计算机中，都是以`000`开始的二进制存储，所以检测出来的结果是对象</span><br><span class="line">  - `typeof` 普通对象/数组对象/正则对象/日期对象 都是`object`</span><br><span class="line">  - `typeof NaN === &#x27;number&#x27;`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  instanceof</span><br></pre></td></tr></table></figure><ul><li>检测当前实例是否属于这个类的</li><li>底层机制：只要当前类出现在实例的原型上，结果都是true</li><li>不能检测基本数据类型</li></ul></li><li><p>```<br>constructor</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 支持基本类型</span><br><span class="line">  - constructor可以随便改，也不准</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Object.prototype.toString.call([val])</span><br></pre></td></tr></table></figure><ul><li>返回当前实例所属类信息</li></ul></li></ul><blockquote><p>判断 <code>Target</code> 的类型，单单用 <code>typeof</code> 并无法完全满足，这其实并不是 <code>bug</code>，本质原因是 <code>JS</code> 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p></blockquote><ul><li>基本类型(<code>null</code>): 使用 <code>String(null)</code></li><li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: - 直接使用 <code>typeof</code>即可</li><li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li></ul><h3 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3. 数据类型转换"></a><strong>3. 数据类型转换</strong></h3><p>我们先看一段代码，了解下大致的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;123&#x27;</span> == <span class="number">123</span>   <span class="comment">// false or true?</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span>    <span class="comment">// false or true?</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span>        <span class="comment">// false or true?</span></span><br><span class="line">[] == <span class="number">0</span>        <span class="comment">// false or true?</span></span><br><span class="line">[] == <span class="string">&#x27;&#x27;</span>       <span class="comment">// false or true?</span></span><br><span class="line">[] == ![]      <span class="comment">// false or true?</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">//  false or true?</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>)     <span class="comment">// 返回什么？</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>)      <span class="comment">// 返回什么？</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>);    <span class="comment">// 返回什么？</span></span><br><span class="line">&#123;&#125;+<span class="number">10</span>           <span class="comment">// 返回什么？</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="number">200</span>); <span class="comment">// 这里打印出来是多少？</span></span><br></pre></td></tr></table></figure><blockquote><p>首先我们要知道，在 <code>JS</code> 中类型转换只有三种情况，分别是：</p></blockquote><ul><li>转换为布尔值</li><li>转换为数字</li><li>转换为字符串</li></ul><p><img src="https://s.poetries.work/gitee/2020/07/1.png" alt="img"></p><h4 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a><strong>转Boolean</strong></h4><blockquote><p>在条件判断时，除了 <code>undefined</code>，<code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>)          <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>)        <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">1</span>)          <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">13</span>)         <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;12&#x27;</span>)       <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="对象转原始类型"><a href="#对象转原始类型" class="headerlink" title="对象转原始类型"></a><strong>对象转原始类型</strong></h4><blockquote><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下</p></blockquote><ul><li>如果已经是原始类型了，那就不需要转换了</li><li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li><li>调用 <code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li><li>如果都没有返回原始类型，就会报错</li></ul><blockquote><p>当然你也可以重写 <code>Symbol.toPrimitive</code>，该方法在转原始类型时调用优先级最高。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><h4 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a><strong>四则运算符</strong></h4><blockquote><p>它有以下几个特点：</p></blockquote><ul><li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li><li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// &quot;41,2,3&quot;</span></span><br></pre></td></tr></table></figure><ul><li>对于第一行代码来说，触发特点一，所以将数字 <code>1</code> 转换为字符串，得到结果 <code>&#39;11&#39;</code></li><li>对于第二行代码来说，触发特点二，所以将 <code>true</code> 转为数字 <code>1</code></li><li>对于第三行代码来说，触发特点二，所以将数组通过 <code>toString</code>转为字符串 <code>1,2,3</code>，得到结果 <code>41,2,3</code></li></ul><blockquote><p>另外对于加法还需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code></p></blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#x27;a&#x27; + + &#x27;b&#x27; // -&gt; &quot;aNaN&quot;</span><br></pre></td></tr></table></figure><ul><li>因为 <code>+ &#39;b&#39;</code> 等于 <code>NaN</code>，所以结果为 <code>&quot;aNaN&quot;</code>，你可能也会在一些代码中看到过 <code>+ &#39;1&#39;</code>的形式来快速获取 <code>number</code> 类型。</li><li>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">&#x27;3&#x27;</span> <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * [] <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h4><ul><li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li><li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a &gt; -<span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p></blockquote><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a><strong>强制类型转换</strong></h4><blockquote><p>强制类型转换方式包括 <code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>、<code>toString()</code>、<code>String()</code>、<code>Boolean()</code>，这几种方法都比较类似</p></blockquote><ul><li><code>Number()</code> 方法的强制转换规则</li><li>如果是布尔值，<code>true</code> 和 <code>false</code> 分别被转换为 <code>1</code> 和 <code>0</code>；</li><li>如果是数字，返回自身；</li><li>如果是 <code>null</code>，返回 <code>0</code>；</li><li>如果是 <code>undefined</code>，返回 <code>NaN</code>；</li><li>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 <code>0X / 0x</code> 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 <code>0</code>；如果不是以上格式的字符串，均返回 NaN；</li><li>如果是 <code>Symbol</code>，抛出错误；</li><li>如果是对象，并且部署了 <code>[Symbol.toPrimitive]</code> ，那么调用此方法，否则调用对象的 <code>valueOf()</code> 方法，然后依据前面的规则转换返回的值；如果转换的结果是 <code>NaN</code> ，则调用对象的 <code>toString()</code> 方法，再次依照前面的顺序转换返回对应的值。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>);        <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;0111&#x27;</span>);      <span class="comment">//111</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>);        <span class="comment">//0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>);          <span class="comment">//0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;1a&#x27;</span>);        <span class="comment">//NaN</span></span><br><span class="line"><span class="title class_">Number</span>(-<span class="number">0X11</span>);       <span class="comment">//-17</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;0X11&#x27;</span>)       <span class="comment">//17</span></span><br></pre></td></tr></table></figure><h4 id="Object-的转换规则"><a href="#Object-的转换规则" class="headerlink" title="Object 的转换规则"></a><strong>Object 的转换规则</strong></h4><blockquote><p>对象转换的规则，会先调用内置的 <code>[ToPrimitive]</code> 函数，其规则逻辑如下：</p></blockquote><ul><li>如果部署了 <code>Symbol.toPrimitive</code> 方法，优先调用再返回；</li><li>调用 <code>valueOf()</code>，如果转换为基础类型，则返回；</li><li>调用 <code>toString()</code>，如果转换为基础类型，则返回；</li><li>如果都没有返回基础类型，会报错。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="number">1</span>); <span class="comment">// 输出5</span></span><br><span class="line"><span class="comment">// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&#x27;31&#x27;(字符串拼接)</span></span><br><span class="line"><span class="comment">// 再看两个特殊的case：</span></span><br><span class="line"><span class="number">10</span> + &#123;&#125;</span><br><span class="line"><span class="comment">// &quot;10[object Object]&quot;，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&#x27;+&#x27;运算，按照字符串拼接规则来，参考&#x27;+&#x27;的规则C</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">undefined</span>,<span class="number">4</span>,<span class="number">5</span>] + <span class="number">10</span></span><br><span class="line"><span class="comment">// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&#x27;+&#x27;的第3条规则</span></span><br></pre></td></tr></table></figure><h4 id="‘-’-的隐式类型转换规则"><a href="#‘-’-的隐式类型转换规则" class="headerlink" title="‘==’ 的隐式类型转换规则"></a><strong>‘==’ 的隐式类型转换规则</strong></h4><ul><li>如果类型相同，无须进行类型转换；</li><li>如果其中一个操作值是 <code>null</code> 或者 <code>undefined</code>，那么另一个操作符必须为 <code>null</code> 或者 <code>undefined</code>，才会返回 <code>true</code>，否则都返回 <code>false</code>；</li><li>如果其中一个是 <code>Symbol</code> 类型，那么返回 <code>false</code>；</li><li>两个操作值如果为 <code>string</code> 和 number 类型，那么就会将字符串转换为 <code>number</code>；</li><li>如果一个操作值是 <code>boolean</code>，那么转换成 <code>number</code>；</li><li>如果一个操作值为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，就会把 <code>object</code> 转为原始类型再进行判断（调用 <code>object</code> 的 <code>valueOf/toString</code> 方法进行转换）。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>       <span class="comment">// true  规则2</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>               <span class="comment">// false 规则2</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">null</span>              <span class="comment">// false 规则2</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span>                 <span class="comment">// true  规则4 字符串转隐式转换成Number之后再对比</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span> == <span class="number">123</span>            <span class="comment">// true  规则4 字符串转隐式转换成Number之后再对比</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>              <span class="comment">// true  e规则 布尔型隐式转换成Number之后再对比</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>               <span class="comment">// true  e规则 布尔型隐式转换成Number之后再对比</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这里a又可以等于1、2、3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span>);  <span class="comment">//true f规则 Object隐式转换</span></span><br><span class="line"><span class="comment">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span></span><br></pre></td></tr></table></figure><h4 id="‘-’-的隐式类型转换规则-1"><a href="#‘-’-的隐式类型转换规则-1" class="headerlink" title="‘+’ 的隐式类型转换规则"></a><strong>‘+’ 的隐式类型转换规则</strong></h4><blockquote><p>‘+’ 号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当 ‘+’ 号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。</p></blockquote><ul><li>如果其中有一个是字符串，另外一个是 <code>undefined</code>、<code>null</code> 或布尔型，则调用 <code>toString()</code> 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li><li>如果其中有一个是数字，另外一个是 <code>undefined</code>、<code>null</code>、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li><li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>        <span class="comment">// 3  常规情况</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="string">&#x27;2&#x27;</span>    <span class="comment">// &#x27;12&#x27; 常规情况</span></span><br><span class="line"><span class="comment">// 下面看一下特殊情况</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">undefined</span>   <span class="comment">// &quot;1undefined&quot; 规则1，undefined转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">null</span>        <span class="comment">// &quot;1null&quot; 规则1，null转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="literal">true</span>        <span class="comment">// &quot;1true&quot; 规则1，true转换字符串</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">1n</span>          <span class="comment">// &#x27;11&#x27; 比较特殊字符串和BigInt相加，BigInt转换为字符串</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>     <span class="comment">// NaN  规则2，undefined转换数字相加NaN</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>          <span class="comment">// 1    规则2，null转换为0</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>          <span class="comment">// 2    规则2，true转换为1，二者相加为2</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1n</span>            <span class="comment">// 错误  不能把BigInt和Number类型直接混合相加</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">3</span>           <span class="comment">// &#x27;13&#x27; 规则3，字符串拼接</span></span><br></pre></td></tr></table></figure><blockquote><p>整体来看，如果数据中有字符串，JavaScript 类型转换还是更倾向于转换成字符串，因为第三条规则中可以看到，在字符串和数字相加的过程中最后返回的还是字符串，这里需要关注一下</p></blockquote><h4 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a><strong>null 和 undefined 的区别？</strong></h4><ul><li>首先 <code>Undefined</code> 和 <code>Null</code> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <code>undefined</code> 和 <code>null</code>。</li><li><code>undefined</code> 代表的含义是未定义， <code>null</code> 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 <code>undefined</code>，<code>null</code> 主要用于赋值给一些可能会返回对象的变量，作为初始化。</li></ul><blockquote><p>其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p></blockquote><ul><li>undefined 在 js 中不是一个保留字，这意味着我们可以使用 <code>undefined</code> 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 <code>undefined</code> 值，比如说 <code>void 0</code>。</li><li>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aaa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化</title>
      <link href="/2017/03/05/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2017/03/05/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>js 中现在比较成熟的有四种模块加载方案：</p></blockquote><ul><li>第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</li><li>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范</li><li>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</li><li>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块</li></ul><blockquote><p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code>的模块化</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// file b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a, b&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">XXX</span> <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>CommonJS</strong></p><blockquote><p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code>解析了。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">a</span> <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，<code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">a</span></span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class="line"><span class="comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基本实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">  <span class="attr">exports</span>: &#123;&#125; <span class="comment">// exports 就是个空对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line"><span class="keyword">var</span> load = <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 导出的东西</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = a</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>再来说说 <code>module.exports</code> 和<code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。</p></blockquote><blockquote><p>对于 <code>CommonJS</code> 和 <code>ES6</code> 中的模块化的两者区别是：</p></blockquote><ul><li>前者支持动态导入，也就是 <code>require($&#123;path&#125;/xx.js)</code>，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 <code>require/exports</code> 来执行的</li></ul><p><strong>AMD</strong></p><blockquote><p><code>AMD</code> 是由 <code>RequireJS</code> 提出的</p></blockquote><p><strong>AMD 和 CMD 规范的区别？</strong></p><ul><li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</li><li>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>AMD</strong>：<code>requirejs</code> 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置</li><li><strong>CMD</strong>：<code>seajs</code> 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近</li><li><strong>CommonJs</strong>：模块输出的是一个值的 <code>copy</code>，运行时加载，加载的是一个对象（<code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li><li><strong>ES6 Module</strong>：模块输出的是一个值的引用，编译时输出接口，<code>ES6</code>模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ul><p><strong>谈谈对模块化开发的理解</strong></p><ul><li>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</li><li>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</li><li>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</li><li>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
